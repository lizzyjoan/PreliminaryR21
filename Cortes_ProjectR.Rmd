---
title: "ProjectR"
author: "Lizzy Ramsey"
date: "4/26/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(projectR)
library(CoGAPS)
library(ggplot2)
library(DESeq2)
library(gplots)
library(dplyr)
library(tibble)
library(AnnotationDbi)
library(devtools)
library(ggbiplot)
library(biomaRt)
library(tidyr)
library(ggalluvial)
library(ggrepel)
```

### Purpose
Publicly available mouse and human datasets of pre/post gene expression in skeletal muscle were used to project mouse patterns onto human data using ProjectR package. The end goal is to find latent variables in mouse gene expression to project onto human data to make mouse data better recapitulate human data.
Built with r getRversion()

  
**Overview**  
Step 1: Load packages  
Step 2: Read in RNAseq raw counts  
Step 3: Normalize using DESeq2  
Step 4: PCA of mouse data  
Step 5: Convert mouse Ensembl gene ID's to symbols  
Step 6: Convert mouse symbols to human symbols  
Step 7: NMF method and visualization
Step 8: PCA method and visualization
Step 9: Clustering method and visualization (in progress)
Step 10: Functional enrichment analysis (in progress)
  
**Data**  
Mouse Data: *GSE97718*  
- fastq's downloaded from ENA  
- data preprocessed with RNA-seq STAR pipeline by Lara Ianov  
  
Human Data: *GSE108643*  
- fastq's downloaded from ENA  
- data preprocessed with RNA-seq STAR pipeline by Lara Ianov  
  
**Read in Mouse Data**  
```{r, copy = TRUE}
#Load in raw counts for Mouse pre/post exercise experiment
mouse_counts <- read.delim("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/mouse210321_fixed_raw_counts.txt", header = TRUE, row.names = 1, sep = "\t", stringsAsFactors = FALSE)
mouse_counts <- mouse_counts[, -c(1:3)]
```


**Make Mouse Metadata Table**  
Metadata/info table not supplied with this study. Using GEO, manually created (see here *https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE97718*)
```{r}
#metadata not included with this dataset.. 
mouse_info <- read.csv("MouseSraRunTable.txt", header = TRUE, sep = ",")
Name <- c("CON_pre4","HFD_pre2","HFD_pre3","HFD_pre4","CON_post1","CON_post2","CON_post3","CON_post4","HFD_post4","CON_pre3","CON_pre2","HFD_post2","HFD_post3","HFD_pre1","CON_pre1","HFD_post1")
mouse_info <- cbind(mouse_info, Name)
#making columns specific to condition (diet and exercise)
mouse_info <- mutate(mouse_info, Diet = ifelse(grepl("HFD", Name, ignore.case = TRUE), "HFD", "CON"))
mouse_info <- mutate(mouse_info, Exercise = ifelse(grepl("pre", Name, ignore.case = TRUE), "pre", "post"))
mouse_info <- column_to_rownames(mouse_info, var = "Name")

```

**Read in Human Data** 
```{r}
#HUMAN data read in
human_data <- read.delim("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/human_fixed_raw_counts.txt", header = TRUE, row.names = 1, sep = "\t")
human_data <- human_data[, -c(1:3)]
human_info <- read.csv("human_info.csv", header = TRUE, sep = ",")
human_info <- human_info[c(1:58),]
#make new label names for human samples
human_info_test <- unite(human_info, col = Name, BMI, PrePost, sep = "_", remove = FALSE)
##NEED TO FIGURE OUT how to add sequence of 1-3 for every 3 columns to give unique names
#human_info_test <- lapply(human_info_test$Name, c(1:3), paste())
#rep(1:14, 4) and then paste0
numbered_list <- c(1:14, 1:15, 1:14, 1:15)
names <- paste(human_info_test$Name, numbered_list, sep = "_")
human_info_test[["Names"]] <- names
human_info <- column_to_rownames(human_info_test, var = "Names")

```

**DESeq2 for Mouse**  
DESeq2 was used to normalize data  

```{r, message=FALSE}
mouse_dds <- DESeqDataSetFromMatrix(mouse_counts, colData = mouse_info, design = ~ Exercise)
mouse_dds <- DESeq(mouse_dds)
#Contrast for log fold change, pre = numerator, post = denominator
mouse_res <- results(mouse_dds, contrast = c("Exercise",  "pre", "post"))
write.csv(as.data.frame(mouse_res), file = "Mouse_DESeq2_results.csv")

mouse_vsd <- vst(mouse_dds, blind = FALSE)
```


```{r}
mouse_deseq2_pca <- DESeq2::plotPCA(mouse_vsd, intgroup = "Exercise", )
mouse_deseq2_pca
```

**DESeq2 for Human**  
DESeq2 was used to normalize data  

```{r, message = FALSE}
#HUMAN normalization
human_dds <- DESeqDataSetFromMatrix(human_data, colData = human_info, design = ~ PrePost)
human_dds <- DESeq(human_dds)
human_res <- results(human_dds, contrast = c("PrePost", "Pre", "Post"))
write.csv(human_res, file = "Human_DESeq_Res.csv")
human_vsd <- vst(human_dds, blind = FALSE)

# trying to get lfc in order
human_de <- cbind(LFC = human_res$log2FoldChange, Pval = human_res$pvalue)
row.names(human_de) <- row.names(human_res)
human_de_df <- as.data.frame(human_de)
human_de_ordered <- human_de_df[order(-human_de_df$LFC), , drop = FALSE]
```

```{r, message = FALSE}
human_vsd_matrix <- assay(human_vsd)
human_deseq2_pca <- plotPCA(human_vsd, intgroup = "PrePost")
human_deseq2_pca
rownames(human_vsd_matrix) <- sub("\\..*", "", rownames(human_vsd_matrix))
#back to df and make ensembl gene rownames into a column
human_vsd_matrix <- human_vsd_matrix %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")
```

**Mouse Gene ID Conversion**  
```{r}
#preparing outputs for conversion
mouse_vsd_matrix <- assay(mouse_vsd)
rownames(mouse_vsd_matrix) <- sub("\\..*", "", rownames(mouse_vsd_matrix))
mouse_vsd2 <- mouse_vsd_matrix %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")
write.csv(mouse_info, file= "New_Mouse_Metadata")

```

**AnnotationDbi for Mouse Symbols**  

```{r, message=FALSE}
#annotation
library(org.Mm.eg.db)
#retrieve conversion info from one ID type to another
#REPLACE test_mouse to mouse_anno
mouse_anno <- AnnotationDbi::select(org.Mm.eg.db, keys = rownames(mouse_vsd_matrix), columns = c("SYMBOL", "GO"),keytype = "ENSEMBL")
#determine indices for non-NA genes
mousenon_na_symbols <- which(is.na(mouse_anno$SYMBOL) == FALSE)
#return only the genes with annotations using indices
mouse_anno <- mouse_anno[mousenon_na_symbols, ]
#determine indices for non-duplicated genes
mouseno_dups_symbols <- which(duplicated(mouse_anno$SYMBOL) == FALSE)
#return only non-dup genes using indices
mouse_anno <- mouse_anno[mouseno_dups_symbols, ]
#add symbols to normalized mouse data
mouse_symbol <- inner_join(mouse_anno, mouse_vsd2, by = "ENSEMBL")
#has GO annotation as well as the other gene ID info
mouse_symbol_GO <- column_to_rownames(mouse_symbol, var = "SYMBOL")
#removing annotations, symbols for row names, format for analysis
mouse_symbol <- mouse_symbol_GO[,c(5:20)]

```

**AnnotationDbi for Human Symbols**  

```{r}
#annotation
BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
#retrieve conversion info from one ID type to another
symbols_human <- AnnotationDbi::select(org.Hs.eg.db, keys = human_vsd_matrix$ENSEMBL, columns = c("SYMBOL", "GO"),keytype = "ENSEMBL")
#determine indices for non-NA genes
non_na <- which(is.na(symbols_human$SYMBOL) == FALSE)
#return only the genes with annotations using indices
symbols_human <- symbols_human[non_na, ]
#determine indices for non-duplicated genes
no_dups_human <- which(duplicated(symbols_human$SYMBOL) == FALSE)
#return only non-dup genes using indices
symbols_human <- symbols_human[no_dups_human, ]
human_symbol_data <- inner_join(symbols_human, human_vsd_matrix, by = "ENSEMBL")
#has GO annotation as well as the other gene ID info
human_symbol_data_GO <- column_to_rownames(human_symbol_data, var = "SYMBOL")
#removing annotations, symbols for row names, format for analysis
human_symbol_data <- human_symbol_data_GO[,5:62]

```

**Convert from mouse to human orthologous symbols**  
To be able to compare gene expression data from mouse to human, must convert first to orthologous genes

```{r}
## Basic function to convert mouse to human gene names
convertMouseGeneList <- function(x){
require("biomaRt")
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
genesV2 = getLDS(attributes = c("mgi_symbol"), filters = "mgi_symbol", values = x , mart = mouse, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=T)
return(genesV2)
}

```


```{r}
#Use convertMouseGeneList to convert to human genes
mouse_to_human_genes <- convertMouseGeneList(mouse_anno$SYMBOL)
conv_mouse <- mouse_symbol %>% rownames_to_column(., var = "MGI.symbol") %>% left_join(., mouse_to_human_genes, by = "MGI.symbol")
#determine non-NA genes
non_na_mouse <- which(is.na(conv_mouse$HGNC.symbol) == FALSE)
#return only the genes with annotations using indices
conv_mouse <- conv_mouse[non_na_mouse, ]
#determine indices for non-duplicated genes
no_dups_mouse <- which(duplicated(conv_mouse$HGNC.symbol) == FALSE)
#return only non-dup genes using indices
conv_mouse <- conv_mouse[no_dups_mouse, ]
rownames(conv_mouse) <- NULL 
conv_mouse <- conv_mouse %>% as.data.frame() %>% column_to_rownames(., var = "HGNC.symbol") 
conv_mouse <- conv_mouse[,c(2:17)]

```

**ProjectR NMF Using CoGAPS**  
How many patterns? Might need to finish FEA to figure out. 
```{r}
#MOUSE NMF
#parameters for GoGAPS
params <- new("CogapsParams")
params <- setParam(params, "seed", 1000)
params <- setParam(params, "nPatterns", 12)

```


```{r}
#CoGAPS to find patterns in the data
AP_mouse <- CoGAPS(conv_mouse, params, nIterations = 1000)
getMeanChiSq(AP_mouse)
plot(AP_mouse)
```

```{r}
#Trying to plot amplitude
#mouse_featloadings <- as.matrix(AP_mouse)
#mouse_featloadings_df <- as.data.frame(mouse_featloadings)
#row.names(mouse_featloadings) <- row.names(mouse_info)
#mouse_amp <- ggplot(mouse_featloadings_df, aes(axis1 = c(1:16), y = V1))
#mouse_amp <- mouse_amp + geom_line()
#mouse_amp

#Trying alluvial plots using ProjectR's alluvial plot function
#samplenames <- colnames(conv_mouse)
#par(bty = "c", ljoin = "mitre")
#mouse_matplot <- 
#matplot(mouse_featloadings, type = "b", pch = 15:18, col = c(1:4,6), xlab = "Samples", ylab = "Amplitude", main = "Gene Weights of Samples by Patterns")
#legend("topright", pch = 15:18, legend = c("Pattern_1", "Pattern_2", "..."), col = c(1:4, 6))

#mouse_matplot
```

Boxplot for amplitudes
```{r}
mouse_samplefactors <- AP_mouse@sampleFactors %>% as.data.frame() 
#%>% rownames_to_column(., var = "Sample")
#mouse_samplefactors <- cbind(mouse_samplefactors, Exercise = mouse_info$Exercise)

#mouse_samplefactors_split <- as.numeric(factor(mouse_samplefactors$Exercise)) %>% cbind(mouse_samplefactors, ExerciseFactors = mouse_samplefactors_split)
#mouse_samplefactors_split <- split(mouse_samplefactors, mouse_samplefactors$ExerciseFactors)
#mouse_samplefactors <- as.data.frame(mouse_samplefactors)

#Struggling with ggplot
#mouse_boxplot <- ggplot(mouse_samplefactors, aes(x = Exercise, y = Pattern_2)) + geom_boxplot()
mouse_boxplot

baseboxplot <- boxplot(mouse_samplefactors, xlab = "NMF Patterns", ylab = "Sample Weights", las = 2, main = "Sample Factors")
#try splitting into two matrices, pre and post, and then use add to "add boxplot to current plot"

```

 
**Heatmap of Mouse NMF**  
Visualizing NMF object
```{r}
#heatmap
#Error in plot.new() : figure margins too large
#trying par(mar) to change margins
NMF_mouse <-heatmap.2(as.matrix(AP_mouse),col=bluered, trace='none',
                 distfun=function(c) as.dist(1-cor(t(c))) ,
                 cexCol=1,cexRow=.6,scale = "row", main = "Mouse Data: nPatterns 14, nIterations 5000", labRow = rownames(conv_mouse), xlab = "Patterns",
                 hclustfun=function(x) hclust(x, method="average"))
pdf("NewMouse_NMF_nPat14_nIt5000.pdf", NMF_mouse)
NMF_mouse
```
**NMF Projection**  
The mouse NMF patterns can then be projected onto the human data
```{r}
#NMF to project into PC's from mouse expression data
human_data <- as.matrix(human_symbol_data)
human_NMF <- projectR(human_data,loadings=AP_mouse, full=TRUE,
                     dataNames=rownames(human_data))

#Using metadata and NMF projection to make a dataframe that can be plotted
 human_meta <- column_to_rownames(human_info, var = "SRR")
#dNMF <- human_NMF %>% data.frame() %>% t() %>% cbind(., )
projection_NMF <- human_NMF$projection %>% t() %>% cbind(., human_meta)
pval_NMF <- human_NMF$pval
#plot pca
projection_plot <- ggplot(projection_NMF, aes(x = Pattern_1, y = Pattern_2, colour = PrePost)) + geom_point() + ggtitle("Mouse Data NMF Patterns Projected onto Human Data")
projection_plot
ggsave("NMF_Mouse_Projected_to_Human_14pat5000it.pdf", projection_plot)


```

**PC Projection**  
Another method to projections. Principal components are found for mouse and human data. Mouse PC's are used for loadings and projected onto human data.  
```{r}
pc_human <- prcomp(t(human_symbol_data))
pc_mouse <- prcomp(t(conv_mouse))
#find variance
pc_var_mouse <- round(((pc_mouse$sdev)^2/sum(pc_mouse$sdev^2))*100,2)
pca_mouse_df <- data.frame(cbind(pc_mouse$x, mouse_info))

```

```{r}
PCA_projectr <- projectR(human_data, loadings = pc_mouse, full = TRUE, dataNames = rownames(human_data))
human_meta_t <- t(human_meta)
PCA_projectr_t <- t(PCA_projectr[[1]])
PCA_projectr_df <- cbind(PCA_projectr_t, human_meta)
#[1] "18282 row names matched between data and loadings"
#[1] "Updated dimension of data: 18282 58"

#Plot PCA
dPCA <- data.frame(cbind(t(PCA_projectr[[1]]),PCA_projectr_df))
projected_PCA <- ggplot(PCA_projectr_df, aes(x = PC1, y = PC2, colour = PrePost)) + geom_point() +  ggtitle("Mouse Principal Components Projected onto Human Data")
projected_PCA
ggsave("PCA_Method_Mouse_Projected_onto_Human.pdf", projected_PCA)
```

```{r}
#Alluvial Plot
#need a character vector of annotations for alluvial
mouse_GO_list <- mouse_symbol_GO$ONTOLOGY
human_GO_t <- t(human_symbol_data_GO)
alluvial <- alluvialMat(projection = human_NMF, annotations = human_info$BMI, plot = TRUE)
alluvial

ggalluvial <- ggplot(data = mouse_DE_top50,
       aes(axis1 = CON_pre4, axis2 = CON_post4, y = X) +
  scale_x_discrete(limits = c("Sample", "PrePost Exercise"), expand = c(.2, .05)) +
  xlab(" ") +
  geom_alluvium(aes(fill = BMI)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  theme_minimal() +
  ggtitle(" "))

ggalluvial
```

**ProjectR Clustering Method**  
There’s 2 methods: cluster2pattern finds correlation of each gene’s expression by mean of cluster to define continuous weights. Then intersector tests significant overlap between 2 clustering objects. For these purposes, I think cluster2pattern is better for finding what we want (differences between clusters rather than overlaps). Requires a clustering object first.
```{r, message = FALSE}
#TOP 50 DIFFERENTIALLY EXPRESSED GENES
#error "the standard deviation is zero" for cluster2pattern
#checking standard deviation for each gene
stdevs <- apply(conv_mouse, 1, sd)
mouse_stdev <- cbind(conv_mouse, stdevs)
mouse_stdev <- slice_max(mouse_stdev, order_by = stdevs, n = 250)
mouse_top250 <- mouse_stdev[,-17]
write.csv2(mouse_top250, file = "Mouse_Top250_DEG.csv")
```

```{r}
library(fpc)
#pamk: partitioning around medoids clustering with the number of clusters estimated by optimum average silhouette width 
#part_clust_mouse <- pamk(stdevs, scaling = TRUE)
#plot(part_clust_mouse$pamobject)

#  Hierarchical Clustering
mouse_dist <- dist(mouse_top250, method = "euclidean") # distance matrix 
hclust_fit <- hclust(mouse_dist, method="average")
plot(hclust_fit) # display dendrogram
#looks like 3 clusters would be best 
```

```{r}
#  Hierarchical Clustering with Bootstrapped p values
library(pvclust)
#pvclust() provides p-values for hierarchical clustering based on multiscale bootstrap resampling-clusters that are highly supported by the data will have large p values.
#pvclust clusters columns, not rows: transpose your data before using
fit <- pvclust(mouse_top50, method.hclust="average",
   method.dist="euclidean")
hclust_dendro_sig <- plot(fit) 
pvrect(fit, alpha=.90) # add rectangles around groups highly supported by the data


pdf(file = "Mouse_Hclust_Dendrogram.pdf", hclust_dendro_sig)

#clusterplotR... what is this/how to use this/should I use this?
#mouse_clusterplotr <- clusterPlotR(mouse_top50, hclust_fit, NC = 3)
```

Output of the cluster2pattern function is a pclust class object; specifically, a matrix of
genes (rows) by clusters (columns). A gene’s value outside of its assigned cluster is zero. For
the cluster containing a given gene, the gene’s value is the corelation of the gene’s expression
to the mean of that cluster.
```{r}

#output of the cluster2pattern function is a pclust class object; specifically, a matrix of
#genes (rows) by clusters (columns). A gene’s value outside of its assigned cluster is zero. For
#the cluster containing a given gene, the gene’s value is the corelation of the gene’s expression
#to the mean of that cluster.
mouse_clusters <- cluster2pattern(hclust_fit, NP = 2, Data = mouse_top250)

cluster_plot <- ggplot(as.data.frame(mouse_clusters), aes(x = V1, y = V2, label = rownames(mouse_clusters))) + geom_point() + ggtitle("Mouse Clusters") + geom_text_repel()
cluster_plot

#join these genes to their GO terms? 
#mouse_clusters_GO <- left_join()
#mouse_clusterplot <- clusterPlotR(cdata = mouse_top50, cls = hclust_fit, NC = 1, mouse_info$Exercise)
#Error in matrix(ncol = dim(cData)[2], nrow = length(cls1)) : non-numeric matrix extent
```
Projecting mouse clusters onto human data
```{r}
#need to use the top 50 genes from mouse DE to pull those genes from human and then project cluster object from cluster2pattern onto human data 
top50_list <- rownames_to_column(mouse_top50, var = "SYMBOL")
human_list <- rownames_to_column(human_symbol_data_GO, var = "SYMBOL")
top50_list <- semi_join(human_list, top50_list, by = "SYMBOL")
human_top50 <- column_to_rownames(top50_list, var = "SYMBOL")
human_top50 <- human_top50[,5:62]
human_top50 <- as.matrix(human_top50)

```


```{r}
cluster_projection <- projectR(human_top50, loadings = mouse_clusters, full = TRUE, dataNames = rownames(human_top50))
#combining projection with metadata and preparing for PCA
cluster_projection_t <- t(cluster_projection[[1]])
cluster_projection_df <- cbind(cluster_projection_t, human_meta)
cluster_projection_plot <- ggplot(cluster_projection_df, aes(x = x1, y = x2, colour = PrePost)) + geom_point() + ggtitle("Mouse Clusters Projected onto Human Data")
cluster_projection_plot
ggsave("Mouse_Clusters_Projection.pdf", cluster_projection_plot)

```

## Using Differentially Expressed Genes for Functional Enrichment Analysis ##

**AnnotationDbi for DESeq2 Mouse Results**  

```{r, message=FALSE}
#Pull DESeq2 results for LFC and P-values, get rid of decimals in ensembl ID's
mouse_de <- cbind(LFC = mouse_res$log2FoldChange, Pval = mouse_res$pvalue)
row.names(mouse_de) <- row.names(mouse_res)
rownames(mouse_de) <- sub("\\..*", "", rownames(mouse_de))
mouse_de_df <- mouse_de %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")
```

```{r}
#Join annotations to DE gene list
mouse_symbol_de <- inner_join(mouse_anno, mouse_de_df, by = "ENSEMBL")
mouse_symbol_GO_de <- column_to_rownames(mouse_symbol_de, var = "SYMBOL")
#This table has ensembl gene ID's, GO info, differential expression and p-values
write.csv(mouse_symbol_GO_de, "Mouse_DE_GO.csv")
#Only need LFC and p-values for FEA
mouse_symbol_de <- mouse_symbol_GO_de[,c(5,6)]
```

```{r}
#Mouse symbols need to be converted to human symbols for downstream analysis
#Use convertMouseGeneList to convert to human genes
#mouse_to_human_genes_de <- convertMouseGeneList(mouse_anno$SYMBOL)
#conv_mouse_de <- mouse_symbol_de %>% rownames_to_column(., var = "MGI.symbol") %>% #left_join(., mouse_to_human_genes_ge, by = "MGI.symbol")

#determine non-NA genes
#non_na_mouse_de <- which(is.na(conv_mouse_de$HGNC.symbol) == FALSE)

#return only the genes with annotations using indices
#conv_mouse_de <- conv_mouse_de[non_na_mouse_de, ]

#determine indices for non-duplicated genes
#no_dups_mouse_de <- which(duplicated(conv_mouse_de$HGNC.symbol) == FALSE)

#return only non-dup genes using indices
#conv_mouse_de <- conv_mouse_de[no_dups_mouse_de, ]
#rownames(conv_mouse_de) <- NULL 
#conv_mouse_de <- conv_mouse_de %>% as.data.frame() %>% column_to_rownames(., var = "HGNC.symbol") 
#conv_mouse_de <- conv_mouse_de[,c(2:17)]

```

Might try to visualize using UMAP (Uniform Manifold Approximation and Projection)
```{r}

#library(umap)
#mouse_umap <- umap(mouse_DE_top50)

```
```{r}
#Gene weights by latent variables
mouse_geneweights <- AP_mouse@loadingStdDev
mouse_geneweights2 <- rownames_to_column(as.data.frame(mouse_geneweights), var = "SYMBOL")
mouse_go2 <- rownames_to_column(mouse_symbol_GO, var = "SYMBOL")
mouse_weightgo <- left_join(mouse_geneweights2, mouse_go2, by = "SYMBOL")
##NOTICED: mouse_go has not been converted to human .. 

#mouse_geneweights_matrix <- rownames_to_column(., var = "") left_join(mouse_geneweights )

```





