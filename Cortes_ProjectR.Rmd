---
title: "ProjectR"
author: "Lizzy Ramsey"
date: "2021/07/08"
output:
  html_document:
    toc: true
    toc_float: true
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(projectR)
library(CoGAPS)
library(ggplot2)
library(DESeq2)
library(gplots)
library(dplyr)
library(tibble)
library(AnnotationDbi)
library(devtools)
library(ggbiplot)
library(biomaRt)
library(tidyr)
library(ggalluvial)
library(ggrepel)
library(gprofiler2)
library(EnsDb.Hsapiens.v86)
library(viridis)
library(reshape2)
BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
```

### Purpose  
Publicly available mouse and human datasets of pre/post gene expression in skeletal muscle were used to project mouse patterns onto human data using ProjectR package. The end goal is to find latent variables in mouse gene expression to project onto human data to make mouse data better recapitulate human data.  
Built with R `r getRversion()`  
[Lab notebook](https://docs.google.com/document/d/1YcSzWmBNcq038HekdMqUrlnSpORaMbX597MM1hvmTdU/edit)  
[Wrike project](https://www.wrike.com/open.htm?id=657384229)  
  

**Data**  
Mouse Data: [GSE97718](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE97718)  
* 16 samples  
* Control diet (n=8) high fat diet (n=8)  
* Pre and post exercise samples collected from each mouse  
* RNA isolated from quadricep skeletal muscle  
* fastq's downloaded from ENA  
* data preprocessed with RNA-seq STAR pipeline by Lara Ianov  
  
Human Data: [GSE108643](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE108643)  
* 59 samples  
* Participants divided by BMI: lean ((BMI<25, 18.5- 24.1 kg/m2, n=15) and Ov/Ob (BMI≥25, 25.5- 36.9 kg/m2, n=15)  
* Pre and post exercise samples collected from each participant  
* RNA isolated from vastus lateralis muscle biopsies  
* fastq's downloaded from ENA  
* data preprocessed with RNA-seq STAR pipeline by Lara Ianov  
  
System which operations were done on: MacBook Pro (16-inch, 2019), Processor 2.4 GHz 8-Core Intel Core i9, Memory 64 GB 2667 MHz DDR4, Graphics AMD Radeon Pro 5300M 4 GB Intel UHD Graphics 630 1536 MB

### Read in Mouse Data 
```{r Mouse_ReadIn}
#Load in raw counts for Mouse pre/post exercise experiment
mouse_counts <- read.delim("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/mouse210321_fixed_raw_counts.txt", header = TRUE, row.names = 1, sep = "\t", stringsAsFactors = FALSE)
mouse_counts <- mouse_counts[, -c(1:3)]
```


**Make Mouse Metadata Table**   
Metadata/info table not supplied with this study. Using GEO, manually created (see here *https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE97718*)
```{r Mouse_Metadata}
#metadata not included with this dataset.. 
mouse_info <- read.csv("MouseSraRunTable.txt", header = TRUE, sep = ",")
Name <- c("CON_pre4","HFD_pre2","HFD_pre3","HFD_pre4","CON_post1","CON_post2","CON_post3","CON_post4","HFD_post4","CON_pre3","CON_pre2","HFD_post2","HFD_post3","HFD_pre1","CON_pre1","HFD_post1")
mouse_info <- cbind(mouse_info, Name)
#making columns specific to condition (diet and exercise)
mouse_info <- mutate(mouse_info, Diet = ifelse(grepl("HFD", Name, ignore.case = TRUE), "HFD", "CON"))
mouse_info <- mutate(mouse_info, Exercise = ifelse(grepl("pre", Name, ignore.case = TRUE), "pre", "post"))
mouse_info <- column_to_rownames(mouse_info, var = "Name")

```


### Read in Human Data  
```{r Human_ReadIn}
#HUMAN data read in
human_data <- read.delim("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/human_fixed_raw_counts.txt", header = TRUE, row.names = 1, sep = "\t")
human_data <- human_data[, -c(1:3)]
human_info <- read.csv("human_info.csv", header = TRUE, sep = ",")
human_info <- human_info[c(1:58),]
#make new label names for human samples
human_info_test <- unite(human_info, col = Name, BMI, PrePost, sep = "_", remove = FALSE)

numbered_list <- c(1:14, 1:15, 1:14, 1:15)
names <- paste(human_info_test$Name, numbered_list, sep = "_")
human_info_test[["Names"]] <- names
human_info <- column_to_rownames(human_info_test, var = "Names")

```

### Normalization for Mouse 
DESeq2 was used to normalize data  

```{r Mouse_DESeq2, message=FALSE}
mouse_dds <- DESeqDataSetFromMatrix(mouse_counts, colData = mouse_info, design = ~ Exercise)
mouse_dds <- DESeq(mouse_dds)
#Contrast for log fold change, pre = numerator, post = denominator
mouse_res <- results(mouse_dds, contrast = c("Exercise", "post", "pre"))
write.csv(as.data.frame(mouse_res), file = "Mouse_DESeq2_results.csv")

mouse_vsd <- vst(mouse_dds, blind = FALSE)
```


```{r Mouse_DESeq2_PCA}
mouse_deseq2_pca <- DESeq2::plotPCA(mouse_vsd, intgroup = "Exercise", )
mouse_deseq2_pca
```

### Normalization for Human  
DESeq2 was used to normalize data  

```{r Human_DESeq2, message=FALSE}
#HUMAN normalization
human_dds <- DESeqDataSetFromMatrix(human_data, colData = human_info, design = ~ PrePost)
human_dds <- DESeq(human_dds)
human_res <- results(human_dds, contrast = c("PrePost", "Post", "Pre"))
write.csv(human_res, file = "210518_Human_DESeq_Res.csv")
human_vsd <- vst(human_dds, blind = FALSE)

# trying to get lfc in order
human_de <- cbind(LFC = human_res$log2FoldChange, Pval = human_res$pvalue)
row.names(human_de) <- row.names(human_res)
human_de_df <- as.data.frame(human_de)
human_de_ordered <- human_de_df[order(-human_de_df$LFC), , drop = FALSE]
```

```{r Human_DESeq2_PCA, message = FALSE}
human_vsd_matrix <- assay(human_vsd)
human_deseq2_pca <- plotPCA(human_vsd, intgroup = "PrePost")
human_deseq2_pca
rownames(human_vsd_matrix) <- sub("\\..*", "", rownames(human_vsd_matrix))
#back to df and make ensembl gene rownames into a column
human_vsd_matrix <- human_vsd_matrix %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")
```

### Annotation
**Mouse Gene ID Conversion**  
```{r Mouse_ID_Conversion}
#preparing outputs for conversion
mouse_vsd_matrix <- assay(mouse_vsd)
rownames(mouse_vsd_matrix) <- sub("\\..*", "", rownames(mouse_vsd_matrix))
mouse_vsd2 <- mouse_vsd_matrix %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")
write.csv(mouse_info, file= "New_Mouse_Metadata")

```


**AnnotationDbi for Mouse Symbols**  
AnnotationDbi::idConverter can convert from one ID type of a species and map to orthologous genes and convert to another gene ID type... However, for human, it uses 'hom.Mm.inp.db' and this database is deprecated and no longer works on Bioconductor past version 3.12  
Just leaving this note because because a functioning version of this would be wonderful  
```{r include=FALSE}
#mouse_anno_test <- AnnotationDbi::idConverter(rownames(mouse_vsd_matrix), srcSpecies = "MUSMU", destSpecies = "HOMSA", srcIDType="ENSEMBL", destIDType="EG")
```


Lengthy process to convert ID's, remove duplicates, and remove NA's, see more info [here](https://hbctraining.github.io/DGE_workshop_salmon/lessons/AnnotationDbi_lesson.html)
```{r Mouse_Annotation, message=FALSE}
#annotation
library(org.Mm.eg.db)
#retrieve conversion info from one ID type to another
mouse_anno <- AnnotationDbi::select(org.Mm.eg.db, keys = rownames(mouse_vsd_matrix), columns = c("SYMBOL", "GO"),keytype = "ENSEMBL")
#determine indices for non-NA genes
mousenon_na_symbols <- which(is.na(mouse_anno$SYMBOL) == FALSE)
#return only the genes with annotations using indices
mouse_anno <- mouse_anno[mousenon_na_symbols, ]
#determine indices for non-duplicated genes
mouseno_dups_symbols <- which(duplicated(mouse_anno$SYMBOL) == FALSE)
#return only non-dup genes using indices
mouse_anno <- mouse_anno[mouseno_dups_symbols, ]
#add symbols to normalized mouse data
mouse_symbol <- inner_join(mouse_anno, mouse_vsd2, by = "ENSEMBL")
#has GO annotation as well as the other gene ID info
mouse_symbol_GO <- column_to_rownames(mouse_symbol, var = "SYMBOL")
#removing annotations, symbols for row names, format for analysis
#!!! this may impact analysis???
#mouse_symbol <- mouse_symbol_GO[,c(5:20)] #THERE WERE 22 COLUMNS AND I CUT OFF TWO OF THEM WITH THIS!!
mouse_symbol <- mouse_symbol_GO[, !names(mouse_symbol_GO) %in% c("ENSEMBL", "GO", "EVIDENCE", "ONTOLOGY")]
```

**AnnotationDbi for Human Symbols**  
```{r Human_Annotation}
#annotation
#retrieve conversion info from one ID type to another
symbols_human <- AnnotationDbi::select(org.Hs.eg.db, keys = human_vsd_matrix$ENSEMBL, columns = c("SYMBOL", "GO"),keytype = "ENSEMBL")
#determine indices for non-NA genes
non_na <- which(is.na(symbols_human$SYMBOL) == FALSE)
#return only the genes with annotations using indices
symbols_human <- symbols_human[non_na, ]
#determine indices for non-duplicated genes
no_dups_human <- which(duplicated(symbols_human$SYMBOL) == FALSE)
#return only non-dup genes using indices
symbols_human <- symbols_human[no_dups_human, ]
human_symbol_data <- inner_join(symbols_human, human_vsd_matrix, by = "ENSEMBL")
#has GO annotation as well as the other gene ID info
human_symbol_data_GO <- column_to_rownames(human_symbol_data, var = "SYMBOL")
#removing annotations, symbols for row names, format for analysis
#commented out previous method: not as reproducible
#human_symbol_data <- human_symbol_data_GO[,5:62]
human_symbol_data <- human_symbol_data_GO[, !names(human_symbol_data_GO) %in% c("ENSEMBL", "GO", "EVIDENCE", "ONTOLOGY")]
```

### Convert Mouse to Human Orthologous Symbols  
To be able to compare gene expression data from mouse to human, must convert first to orthologous genes

```{r Conversion_Function}
## Basic function to convert mouse to human gene names
convertMouseGeneList <- function(x){
require("biomaRt")
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
genesV2 = getLDS(attributes = c("mgi_symbol"), filters = "mgi_symbol", values = x , mart = mouse, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=T)
return(genesV2)
}

```


```{r Mouse_Orthologs}
#Use convertMouseGeneList to convert to human genes
mouse_to_human_genes <- convertMouseGeneList(mouse_anno$SYMBOL)
conv_mouse <- mouse_symbol %>% rownames_to_column(., var = "MGI.symbol") %>% left_join(., mouse_to_human_genes, by = "MGI.symbol")
#determine non-NA genes
non_na_mouse <- which(is.na(conv_mouse$HGNC.symbol) == FALSE)
#return only the genes with annotations using indices
conv_mouse <- conv_mouse[non_na_mouse, ]
#determine indices for non-duplicated genes
no_dups_mouse <- which(duplicated(conv_mouse$HGNC.symbol) == FALSE)
#return only non-dup genes using indices
conv_mouse <- conv_mouse[no_dups_mouse, ]
#set rownames to NULL to be able to set new rownames with HGNC.symbol
rownames(conv_mouse) <- NULL 
conv_mouse <- conv_mouse %>% as.data.frame() %>% column_to_rownames(., var = "HGNC.symbol") 
# originally subsetted like this vv but it's risk and less reproducible
#conv_mouse <- conv_mouse[,c(2:17)]
conv_mouse <- conv_mouse[, !names(conv_mouse) %in% c("MGI.symbol")]
```

### NMF Using CoGAPS for Mouse  
How many patterns? Might need to finish FEA to figure out. 
```{r CoGAPS_Params}
#MOUSE NMF
#parameters for GoGAPS
params <- new("CogapsParams")
params <- setParam(params, "seed", 1000)
params <- setParam(params, "nPatterns", 9)

```


```{r Mouse_CoGAPS}
#CoGAPS to find patterns in the data
#set parameters for number of patterns

AP_mouse <- CoGAPS(conv_mouse, params, nIterations = 5000)
getMeanChiSq(AP_mouse)
```

For Loop for Chi Square Matrix from CoGAPS Runs
```{r eval=FALSE, include=FALSE}
#FOR LOOP
#patterns 7:15 , iterations 1000, 3000, 5000, 6000, 7000, 8000, 10000, 12000, 15000
n_patterns <- c(7:20)
n_iterations <- c(1000, 3000, 5000, 6000, 7000, 8000, 10000, 12000, 15000)

get_chisq <- function(patterns, iterations) {
  chisq_matrix <- matrix(data = 0, nrow = 9, ncol = 9)
  params <- new("CogapsParams")
  params <- setParam(params, "seed", 1000)
  
  for (i in 1:length(patterns)) {
    params <- setParam(params, "nPatterns", patterns[i])
    for (j in 1:length(iterations)){
      AP <- CoGAPS(human_symbol_data, params, nIterations = iterations[j])
      chi_sq <- getMeanChiSq(AP)
      chisq_matrix[i,j] <- chi_sq
  }
}
  return(chisq_matrix)
  write.csv2(chisq_matrix, file = "/Users/eramsey/Desktop/R21_210302/PreliminaryR21/Human_chisq_matrix.csv")
}

get_chisq(n_patterns, n_iterations)

#write.csv2(chisq_matrix, file = "/Users/eramsey/Desktop/R21_210302/PreliminaryR21/mouse_chisq_matrix.csv")
#chisq_matrix
#best is 5000 iterations, 11 patterns

```

### NMF Using CoGAPS for Human  

```{r Human_CoGAPS}
#CoGAPS to find patterns in the data
AP_human <- CoGAPS(human_symbol_data, params, nIterations = 5000)
getMeanChiSq(AP_human)
plot(AP_human)
```

Boxplot for Patterns in Mouse
```{r Mouse_Pattern_Boxplot, eval=FALSE, include=FALSE}
mouse_samplefactors <- AP_mouse@sampleFactors %>% as.data.frame() 
mouse_samplefactors <- cbind(mouse_samplefactors, Exercise = mouse_info$Exercise)

#try grouping pre/post exercise into two different matrices, and then combine them into a boxplot
pre_exercise <- dplyr::filter(mouse_samplefactors, Exercise == "pre")
pre_exercise <- subset(pre_exercise, select = -Exercise)
post_exercise <- dplyr::filter(mouse_samplefactors, Exercise == "post")
post_exercise <- subset(post_exercise, select = -Exercise)
#base r boxplot
boxplot_factors_post <- boxplot(post_exercise, las = 2, ylab = "Sample Factors", main = "Mouse Post Exercise Patterns", col = "powderblue")
#add data points
stripchart(post_exercise, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black')
boxplot_factors_pre <- boxplot(pre_exercise, las = 2, ylab = "Sample Factors", main = "Mouse Pre Exercise Patterns", col = "plum2")
stripchart(pre_exercise, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black')
```

Mouse Pattern Violin Plots
```{r Mouse_PreExercise_Violinplot, eval=FALSE, include=FALSE}
mouse_long_pre <- pre_exercise %>% gather(key = "Patterns", value = "Val") %>% ggplot( aes(x = Patterns, y = Val, fill = Patterns)) + geom_violin()
mouse_long_pre
```


```{r Mouse_PostExercise_Violinplot, eval=FALSE, include=FALSE}
mouse_long_post <- post_exercise %>% gather(key = "Patterns", value = "Val") %>% ggplot( aes(x = Patterns, y = Val, fill = Patterns)) + geom_violin()
mouse_long_post
```



```{r Mouse_Geneweight_Boxplot, results='hide'}
mouse_featureLoadings <- AP_mouse@featureLoadings %>% as.data.frame() 
boxplot_loadings <- boxplot(mouse_featureLoadings, xlab = "NMF Patterns", ylab = "Amplitude", las = 2, main = "Mouse Feature Loadings")

```

Base R Boxplot for Patterns in Human
```{r Basic_Human_Patterns_Boxplot, results='hide'}
human_samplefactors <- AP_human@sampleFactors %>% as.data.frame() 
#%>% rownames_to_column(., var = "Sample")
human_samplefactors <- cbind(human_samplefactors, Exercise = human_info$PrePost)

#split into two matrices, pre and post, and then use add to "add boxplot to current plot"
#group pre/post exercise into two different matrices, and then combine them into a boxplot
pre_exercise_human <- dplyr::filter(human_samplefactors, Exercise == "Pre")
pre_exercise_human <- subset(pre_exercise_human, select = -Exercise)
post_exercise_human <- dplyr::filter(human_samplefactors, Exercise == "Post")
post_exercise_human <- subset(post_exercise_human, select = -Exercise)
#base r boxplot
boxplot_factors_post_human <- boxplot(post_exercise_human, las = 2, ylab = "Sample Factors", main = "Human Post Exercise Patterns", col = "powderblue")
stripchart(post_exercise_human, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black') #add data points
boxplot_factors_pre_human <- boxplot(pre_exercise_human, las = 2, ylab = "Sample Factors", main = "Human Pre Exercise Patterns", col = "plum2")
stripchart(pre_exercise_human, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black')
```
 
ggPlot Boxplot for Patterns in Human
```{r Human_Patterns_ggPlot, fig.align="center", fig.width = 7}
human_sampleFactors <- AP_human@sampleFactors

human_sampleFactors_long <- human_sampleFactors %>% as.data.frame() %>% rownames_to_column(., var = "Sample") %>% pivot_longer( cols = -Sample, names_to = "Patterns", values_to = "Factors")  %>% mutate(Exercise = ifelse(grepl("Pre", Sample, ignore.case = TRUE), "Pre", "Post")) %>% unite( col = "Exercise_Pattern", Patterns, Exercise, sep = "_", remove = FALSE)

human_NMF_boxplot <- ggplot(human_sampleFactors_long, aes(x = Exercise_Pattern, y = Factors)) +
  geom_boxplot(color = "gray60") +
  geom_point(aes(color = Exercise)) +
  geom_jitter(size = 2, alpha = 0.25, width = 0.2) +
  scale_colour_viridis_d() +
  labs(x = "NMF Patterns", y = "Sample Weights") + 
  theme(panel.grid = element_blank(), axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 16), axis.title = element_text(size = 16), title = element_text(size = 18), legend.text = element_text(size = 16)) +
  theme(plot.margin = unit(c(1,1,1.5,1.2),"cm")) + #top, right, bottom, left
    labs(title = "NMF Patterns in Pre/Post Exercise Samples")
human_NMF_boxplot
```

```{r eval=FALSE, include=FALSE}
ggsave("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210706_human_NMF_prepost_pattern_boxplot_bigfont.pdf", human_NMF_boxplot)

```

 
### Mouse NMF Heatmap  
Heatmap set up the same as ProjectR vignette, using hierachical clustering
```{r}
NMF_mouse <-heatmap.2(as.matrix(AP_mouse),col=viridis(100), trace='none',
                 distfun=function(c) as.dist(1-cor(t(c))) ,
                 cexCol=1,cexRow=.6,scale = "row", main = "Mouse NMF", labRow = rownames(conv_mouse), xlab = "Patterns",
                 hclustfun=function(x) hclust(x, method="average"))
```

Mouse NMF ggPlot Heatmap - Data Wrangling
```{r}
mouse_featloadings <- AP_mouse@featureLoadings

#estimate variance for each row 
var_mouse_featloadings <- apply(mouse_featloadings, 1, var)
#top 100 most variable genes
top100_var_mouse_featloadings_names <- names(sort(var_mouse_featloadings, decreasing = TRUE))[1:100]
head(top100_var_mouse_featloadings_names)
```

Mouse - Highest feature/gene weight averages
```{r}
#to look at the highest weighted genes, going to select genes with highest averages across patterns
avg_mouse_featloadings <- apply(mouse_featloadings, 1, mean)

top75_mouse_featloadings_names <- names(sort(avg_mouse_featloadings, decreasing = TRUE))[1:75]
head(top75_mouse_featloadings_names)
```

Mouse data wrangling
```{r}
#data wrangling
top75_mouse_featloadings <- mouse_featloadings[top75_mouse_featloadings_names,]
top75_mouse_featloadings <- as.data.frame(top75_mouse_featloadings)
top75_mouse_featloadings <- rownames_to_column(top75_mouse_featloadings, var = "genes")
dim(top75_mouse_featloadings)
head(top75_mouse_featloadings)
```

Mouse Heatmap  
https://jcoliver.github.io/learn-r/009-expression-heatmaps.html
```{r}
mouse_featloadings_long <- pivot_longer(data = top75_mouse_featloadings, 
                         cols = -genes,
                         names_to = "pattern", 
                         values_to = "feat_weight")
head(mouse_featloadings_long)
mouse_featloadings_long$log.weight <- log(mouse_featloadings_long$feat_weight)
```

### Mouse NMF Amplitude Matrix Heatmap in ggplot  
Heatmap visualization of Amplitude/features/gene weight matrix (CoGAPS output)
```{r}
mouse_featloadings_heatmap <- ggplot(mouse_featloadings_long, mapping = aes(x = pattern, y = genes, fill = log.weight)) + geom_tile() + xlab(label = "Patterns") + ylab(label = "Genes") + theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
mouse_featloadings_heatmap
```

```{r eval=FALSE}
ggsave("210618_NMF_mouse_featloadings_heatmap.pdf", mouse_featloadings_heatmap)
```


### Human NMF Heatmap  
Heatmap visualization of Amplitude/features/gene weight matrix (CoGAPS output)
```{r}
##ggplot Heatmap
human_featloadings <- AP_human@featureLoadings

#estimate variance for each row 
var_human_featloadings <- apply(human_featloadings, 1, var)
#top 100 most variable genes
top20_var_human_featloadings_names <- names(sort(var_human_featloadings, decreasing = TRUE))[1:20] 
head(top20_var_human_featloadings_names)

top20_var_human_featloadings_matrix <- human_featloadings[top20_var_human_featloadings_names,]
```
Human NMF Heatmap  
Clustered heatmap of human NMF feature/amplitude/gene matrix, selecting for top 20 gene weights with greatest variance amongst patterns  
```{r}
#using wide-form of data to cluster
#top20_human_matrix <- as.numeric(top20_human_featloadings)

#png(file = "/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210706_Human_NMF_Variance_GeneWeights.png")  
heatmap.2(top20_var_human_featloadings_matrix,col=viridis, trace='none', margin=c(11,11),
distfun=function(c) as.dist(1-cor(t(c))) , xlab = "NMF Patterns", 
srtCol = 45, cexCol=2,cexRow=1.7, scale = "row",
hclustfun=function(x) hclust(x, method="average"), main = "Most Variable Genes Across NMF Patterns", cex.main = 6
)
#dev.off()

```

Human - highest average weighted genes
```{r}
#to look at the highest weighted genes, going to select genes with highest averages across patterns
avg_human_featloadings <- apply(human_featloadings, 1, mean)

top20_human_featloadings_names <- names(sort(avg_human_featloadings, decreasing = TRUE))[1:20]
head(top20_human_featloadings_names)
```

Human - data wrangling
```{r}
#data wrangling
top20_human_featloadings_matrix <- human_featloadings[top20_human_featloadings_names,]
top20_human_featloadings <- as.data.frame(top20_human_featloadings_matrix)
top20_human_featloadings <- rownames_to_column(top20_human_featloadings, var = "genes")
dim(top20_human_featloadings)
head(top20_human_featloadings)
```
Human - data wrangling  
https://jcoliver.github.io/learn-r/009-expression-heatmaps.html
```{r}
human_featloadings_long <- pivot_longer(data = top20_human_featloadings, 
                         cols = -genes,
                         names_to = "pattern", 
                         values_to = "feat_weight")
head(human_featloadings_long)
human_featloadings_long$log.weight <- log(human_featloadings_long$feat_weight)
head(human_featloadings_long)
```

Human NMF Heatmap
Human Gene/Feature NMF Matrix Heatmap in ggplot, selecting for top highest weightest averages for genes amonst all patterns
```{r}
human_featloadings_heatmap <- ggplot(human_featloadings_long, mapping = aes(x = pattern, y = genes, fill = log.weight)) + 
  geom_tile() +
  labs(title = "Human NMF Feature Weights") +
  xlab(label = "Patterns") + 
  ylab(label = "Top Weighted Genes") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5), axis.text.y = element_text(size = 5)) + 
  scale_fill_viridis(option = "plasma")
human_featloadings_heatmap
```



```{r eval=FALSE, include=FALSE}
ggsave("210706_NMF_human_featloadings_heatmap_bigfont.pdf", human_featloadings_heatmap)
```

### NMF Projection: Mouse onto Human  
The mouse NMF patterns can then be projected onto the human data  
Scatterplot to compare patterns
```{r}
human_data <- as.matrix(human_symbol_data)
human_NMF <- projectR(human_data,loadings=AP_mouse, full=TRUE,
                     dataNames=rownames(human_data))

#pval_NMF <- human_NMF$pval
projection_NMF <- human_NMF$projection %>% t() %>% cbind(., human_info)

#plot scatterplot
projection_plot <- ggplot(projection_NMF, aes(x = Pattern_3, y = Pattern_9, colour = PrePost)) + geom_point() + ggtitle("Mouse Data NMF Patterns Projected onto Human Data")
projection_plot
#ggsave("NMF_Mouse_Projected_to_Human_14pat5000it.pdf", projection_plot)

```



```{r}
ggsave("210628_Scatterplot_Projected_MousetoHuman_Patterns3and9.pdf", projection_plot)

```
PCA to Compare Projected Patterns
```{r eval=FALSE, include=FALSE}
#want pre ad post in the pattern names for row names
projection_NMF_mouse2human_df <- projection_NMF %>% rownames_to_column(var = "Names") %>% pivot_longer(starts_with("Pattern_"), names_to = "Patterns", values_to = "Projections") %>% dplyr::select(c("Names",  "Patterns", "Projections")) %>% unite("PrePost_Patterns", "Patterns", "Names", sep = "_", remove = FALSE) %>% pivot_wider("PrePost_Patterns", names_from = "Patterns", values_from = "Projections")
```

```{r}
#PCA
projection_NMF_mouse2human_pca <- prcomp(human_NMF$projection)
projection_NMF_mouse2human_pca_plot <- ggplot(as.data.frame(projection_NMF_mouse2human_pca$x), aes(x=PC1,y=PC2, colour = "red", "blue")) +geom_point()
#projection_NMF_mouse2human_pca_plot

pc_human <- prcomp(t(human_symbol_data))
pc_mouse <- prcomp(t(conv_mouse))
#find variance
pc_var_mouse <- round(((pc_mouse$sdev)^2/sum(pc_mouse$sdev^2))*100,2)
pca_mouse_df <- data.frame(cbind(pc_mouse$x, mouse_info))

```

Boxplot to Compare Pre/Post Projected Patterns
```{r}
NMF_projection_long <- projection_NMF %>% rownames_to_column(., var = "Sample") %>% pivot_longer(starts_with("Pattern_"), names_to = "Patterns", values_to = "Factors") %>% unite( col = "Exercise_Pattern", Patterns, PrePost, sep = "_", remove = FALSE)


projection_NMF_boxplot <- ggplot(NMF_projection_long, aes(x = Exercise_Pattern, y = Factors)) +
  geom_boxplot(color = "gray60") +
  geom_point(aes(color = PrePost)) +
  geom_jitter(size = 2, alpha = 0.25, width = 0.2) +
  scale_colour_viridis_d() +
  labs(x = "Projected Pre and Post Exercise Patterns", y = "Factors") + 
  theme(panel.grid = element_blank(), axis.text.x = element_text(angle = 45, vjust = 0.5)) +
    labs(title = "Projected Mouse NMF Pre/Post Exercise Patterns onto Human Data")
projection_NMF_boxplot
```

```{r eval=FALSE, include=FALSE}
ggsave("210624_NMF_Projected_MousetoHuman.pdf", projection_NMF_boxplot)
```


Scatterplot to Compare Pre/Post Projected Patterns
```{r}
projection_NMF_scatterplot <- ggplot(NMF_projection_long, aes(x = Patterns, y = Factors)) +
  geom_point(aes(color = PrePost)) +
  geom_jitter(size = 2, alpha = 0.5, width = 0.2) +
  scale_colour_viridis_d() +
  labs(x = "Projected Pre and Post Exercise Patterns", y = "Factors") + 
  theme(panel.grid = element_blank(), axis.text.x = element_text(angle = 45, vjust = 0.5)) +
    labs(title = "Projected Mouse NMF Pre/Post Exercise Patterns onto Human Data")
projection_NMF_scatterplot

```

### NMF Projection: Human onto Mouse  
```{r}
mouse_NMF <- projectR(as.matrix(conv_mouse),loadings=AP_human, full=TRUE,
                     dataNames=rownames(conv_mouse))

projection_NMF_human2mouse <- mouse_NMF$projection %>% t() %>% cbind(., mouse_info)

#plot scatterplot
projection_plot_human2mouse <- ggplot(projection_NMF_human2mouse, aes(x = Pattern_6, y = Pattern_9, colour = Exercise)) + geom_point() + ggtitle("Mouse Data NMF Patterns Projected onto Human Data")
projection_plot_human2mouse
```


### PC Projection  
Another ProjectR method to projections. Principal components are found for mouse and human data. Mouse PC's are used for loadings and projected onto human data.  
  
Make PC's
```{r}
pc_human <- prcomp(t(human_symbol_data))
pc_mouse <- prcomp(t(conv_mouse))
#find variance
pc_var_mouse <- round(((pc_mouse$sdev)^2/sum(pc_mouse$sdev^2))*100,2)
pca_mouse_df <- data.frame(cbind(pc_mouse$x, mouse_info))

```
  
Project PC's
```{r}
PCA_projectr <- projectR(human_data, loadings = pc_mouse, full = TRUE, dataNames = rownames(human_data))
human_meta <- column_to_rownames(human_info_test, var = "SRR")
human_meta_t <- t(human_meta)
PCA_projectr_t <- t(PCA_projectr[[1]])
PCA_projectr_df <- cbind(PCA_projectr_t, human_meta)
#[1] "18282 row names matched between data and loadings"
#[1] "Updated dimension of data: 18282 58"

#Plot PCA
dPCA <- data.frame(cbind(t(PCA_projectr[[1]]),PCA_projectr_df))
projected_PCA <- ggplot(PCA_projectr_df, aes(x = PC1, y = PC2, colour = PrePost)) + 
  geom_point(size = 3.5) + 
  scale_color_viridis_d() +
  theme(panel.grid = element_blank(), axis.text = element_text(size = 16), axis.title = element_text(size = 16), title = element_text(size = 18), legend.text = element_text(size = 16)) +
  ggtitle("Mouse Principal Components \nProjected onto Human Data")
projected_PCA

```

```{r eval=FALSE, include=FALSE}
ggsave("210706_PCA_Method_Mouse_Projected_onto_Human_bigfonts.pdf", projected_PCA)
```



### Clustering Projection  
There’s 2 methods: cluster2pattern finds correlation of each gene’s expression by mean of cluster to define continuous weights. Then intersector tests significant overlap between 2 clustering objects. For these purposes, I think cluster2pattern is better for finding what we want (differences between clusters rather than overlaps). Requires a clustering object first.
```{r, message = FALSE}
#TOP 50 DIFFERENTIALLY EXPRESSED GENES
#checking standard deviation for each gene
stdevs <- apply(conv_mouse, 1, sd)
mouse_stdev <- cbind(conv_mouse, stdevs)
mouse_stdev <- slice_max(mouse_stdev, order_by = stdevs, n = 250)
mouse_top250 <- mouse_stdev[,-17]
write.csv2(mouse_top250, file = "Mouse_Top250_DEG.csv")
```

```{r}
library(fpc)
#pamk: partitioning around medoids clustering with the number of clusters estimated by optimum average silhouette width 
#part_clust_mouse <- pamk(stdevs, scaling = TRUE)
#plot(part_clust_mouse$pamobject)

#  Hierarchical Clustering
mouse_dist <- dist(mouse_top250, method = "euclidean") # distance matrix 
hclust_fit <- hclust(mouse_dist, method="average")
```

```{r}
#  Hierarchical Clustering with Bootstrapped p values
library(pvclust)
#pvclust() provides p-values for hierarchical clustering based on multiscale bootstrap resampling-clusters that are highly supported by the data will have large p values.
#pvclust clusters columns, not rows: transpose your data before using
fit <- pvclust(mouse_top250, method.hclust="average",
   method.dist="euclidean")
hclust_dendro_sig <- plot(fit) 
pvrect(fit, alpha=.90) # add rectangles around groups highly supported by the data
```

```{r eval=FALSE, include=FALSE}
pdf(file = "Mouse_Hclust_Dendrogram.pdf", hclust_dendro_sig)
```


**Clustering in Human Data**  
Hierarchical Clustering with Bootstrapped p values  
**pvclust()** provides p-values for hierarchical clustering based on multiscale bootstrap resampling-clusters that are highly supported by the data will have large p values. (Note: pvclust clusters columns, not rows: transpose your data before using)  

```{r}
#TOP 50 DIFFERENTIALLY EXPRESSED GENES
human_stdevs <- apply(human_symbol_data, 1, sd)
human_stdev <- cbind(human_symbol_data, human_stdevs)
human_stdev <- slice_max(human_stdev, order_by = human_stdevs, n = 50)
human_top250 <- human_stdev[,-17]
write.csv2(human_top250, file = "Human_Top50_DEG.csv")


fit_human <- pvclust(human_top250, method.hclust="average",
   method.dist="euclidean")
human_hclust_dendro_sig <- plot(fit_human) 
#pvrect(fit, alpha=.90) # add rectangles around groups highly supported by the data

```


Output of the cluster2pattern function is a pclust class object; specifically, a matrix of
genes (rows) by clusters (columns). A gene’s value outside of its assigned cluster is zero. For
the cluster containing a given gene, the gene’s value is the correlation of the gene’s expression
to the mean of that cluster.
```{r}
mouse_clusters <- cluster2pattern(hclust_fit, NP = 2, Data = mouse_top250)

```

Projecting mouse clusters onto human data
```{r}
#need to use the top 50 genes from mouse DE to pull those genes from human and then project cluster object from cluster2pattern onto human data 
top50_list <- rownames_to_column(mouse_top250, var = "SYMBOL")
human_list <- rownames_to_column(human_symbol_data_GO, var = "SYMBOL")
top50_list <- semi_join(human_list, top50_list, by = "SYMBOL")
mouseToHumanTop50 <- column_to_rownames(top50_list, var = "SYMBOL")
mouseToHumanTop50 <- mouseToHumanTop50[,5:62]
mouseToHumanTop50 <- as.matrix(mouseToHumanTop50)

```


```{r}
cluster_projection <- projectR(mouseToHumanTop50, loadings = mouse_clusters, full = TRUE, dataNames = rownames(mouseToHumanTop50))
#combining projection with metadata and preparing for PCA
cluster_projection_t <- t(cluster_projection[[1]])
cluster_projection_df <- cbind(cluster_projection_t, human_meta)
cluster_projection_plot <- ggplot(cluster_projection_df, aes(x = x1, y = x2, colour = PrePost)) + geom_point() + ggtitle("Mouse Clusters Projected onto Human Data")
cluster_projection_plot
ggsave("Mouse_Clusters_Projection.pdf", cluster_projection_plot)

```


### Functional Enrichment Analysis  

Mouse ggprofiler https://biit.cs.ut.ee/gprofiler/page/r  
g:Profiler uses all the genes annotated to that term as an input (in this case about six hundred human genes associated to heart development). Fully numeric identifiers need to be prefixed with the corresponding namespace. g:Profiler will automatically prefix all the detected numeric IDs using the prefix determined by the selected numeric namespace parameter.  
gost enables to perform functional profiling of gene lists. The function performs statistical enrichment analysis to find over-representation of functions from Gene Ontology, biological pathways like KEGG and Reactome, human disease annotations, etc. This is done with the hypergeometric test followed by correction for multiple testing.  
In order to reduce the amount of false positives, a multiple testing correction method is applied to the enrichment p-values. By default, our tailor-made algorithm g:SCS is used (correction_method = "gSCS" with synonyms g_SCS and analytical), but there are also options to apply the Bonferroni correction (correction_method = "bonferroni") or FDR (correction_method = "fdr"). The adjusted p-values are reported in the results.  
```{r eval=FALSE, include=FALSE}
#input needs to be a dataframe with genes and p values, so each pattern will need its own dataframe
#sample_factors has already been extracted from AP_human, need to do the same with the stdev
#make loop for this in the future
mouse_feature <- as.data.frame(AP_mouse@featureLoadings)
mouse_feature_stdev <- as.data.frame(AP_mouse@loadingStdDev)
pattern1_mouse <- dplyr::select(mouse_feature, Pattern_1) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_1)
pattern2_mouse <- dplyr::select(mouse_feature, Pattern_2) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_2)
pattern3_mouse <- dplyr::select(mouse_feature, Pattern_3) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_3)
head(pattern3_mouse)
pattern4_mouse <- dplyr::select(mouse_feature, Pattern_4) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_4)
pattern5_mouse <- dplyr::select(mouse_feature, Pattern_5) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_5)
pattern6_mouse <- dplyr::select(mouse_feature, Pattern_6) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_6)
pattern7_mouse <- dplyr::select(mouse_feature, Pattern_7) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_7)
pattern8_mouse <- dplyr::select(mouse_feature, Pattern_8) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_8)
pattern9_mouse <- dplyr::select(mouse_feature, Pattern_9) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_9)
```


```{r eval=FALSE, include=FALSE}
#Filtering for highest weighted genes
#FILTERING BY STD DEV... Should I have done this? Try without filtering?
#want to look at just the significant genes of patterns 3 and 1
#pattern3_sig_mouse <- pattern3_mouse[pattern3_mouse$StdDev < 0.05,]
#pattern1_sig_mouse <- pattern1_mouse[pattern1_mouse$StdDev < 0.05,]

#narrow down significant genes list by selecting the highest weighted genes
#REDO, and try instead of std dev filtering
#top150_mouse_pattern1 <- slice_max(pattern1_mouse, order_by = Pattern_1, n = 150)
#top150_mouse_pattern2 <- slice_max(pattern2_mouse, order_by = Pattern_2, n = 150)
#top150_mouse_pattern3 <- slice_max(pattern3_mouse, order_by = Pattern_3, n = 150)
#top150_mouse_pattern4 <- slice_max(pattern4_mouse, order_by = Pattern_4, n = 150)
#top150_mouse_pattern5 <- slice_max(pattern5_mouse, order_by = Pattern_5, n = 150)
#top150_mouse_pattern6 <- slice_max(pattern6_mouse, order_by = Pattern_6, n = 150)
#top150_mouse_pattern7 <- slice_max(pattern7_mouse, order_by = Pattern_7, n = 150)
#top150_mouse_pattern8 <- slice_max(pattern8_mouse, order_by = Pattern_8, n = 150)
#top150_mouse_pattern9 <- slice_max(pattern9_mouse, order_by = Pattern_9, n = 150)

```


```{r eval=FALSE, include=FALSE}
#Making named lists for gost() input
#named list so genes names are retained and not changed to query_1 from gost()
#pattern3_sig_mouse <- as.list(pattern3_sig_mouse, all.names = TRUE)
top150_mouse_pattern1_names <- rownames(top150_mouse_pattern1) %>% as.list()
names(top150_mouse_pattern1_names) <- rownames(top150_mouse_pattern1)
top150_mouse_pattern2_names <- rownames(top150_mouse_pattern2) %>% as.list()
names(top150_mouse_pattern2_names) <- rownames(top150_mouse_pattern2)
top150_mouse_pattern3_names <- rownames(top150_mouse_pattern3) %>% as.list()
names(top150_mouse_pattern3_names) <- rownames(top150_mouse_pattern3)
top150_mouse_pattern4_names <- rownames(top150_mouse_pattern4) %>% as.list()
names(top150_mouse_pattern4_names) <- rownames(top150_mouse_pattern4)
top150_mouse_pattern5_names <- rownames(top150_mouse_pattern5) %>% as.list()
names(top150_mouse_pattern5_names) <- rownames(top150_mouse_pattern5)
top150_mouse_pattern6_names <- rownames(top150_mouse_pattern6) %>% as.list()
names(top150_mouse_pattern6_names) <- rownames(top150_mouse_pattern6)
top150_mouse_pattern7_names <- rownames(top150_mouse_pattern7) %>% as.list()
names(top150_mouse_pattern7_names) <- rownames(top150_mouse_pattern7)
top150_mouse_pattern8_names <- rownames(top150_mouse_pattern8) %>% as.list()
names(top150_mouse_pattern8_names) <- rownames(top150_mouse_pattern8)
top150_mouse_pattern9_names <- rownames(top150_mouse_pattern9) %>% as.list()
names(top150_mouse_pattern9_names) <- rownames(top150_mouse_pattern9)

```


```{r eval=FALSE, include=FALSE}
#gost() run for each pattern
gost_res_mouse_1 <- gost(query = top150_mouse_pattern1_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_2 <- gost(query = top150_mouse_pattern2_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_3 <- gost(query = top150_mouse_pattern3_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_4 <- gost(query = top150_mouse_pattern4_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_5 <- gost(query = top150_mouse_pattern5_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_6 <- gost(query = top150_mouse_pattern6_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_7 <- gost(query = top150_mouse_pattern7_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_8 <- gost(query = top150_mouse_pattern8_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)

gost_res_mouse_9 <- gost(query = top150_mouse_pattern9_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("KEGG"), as_short_link = FALSE)


head(gost_res_mouse_9)
```


```{r eval=FALSE, include=FALSE}
#top GO terms 
gost_mouse_publish <- publish_gostplot(gost_plot_mouse, highlight_terms = c("GO:0005737", "GO:0005515", "GO:0071840"), filename = "/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210614_gost_mouse_publishplot.pdf" ) 

gost_mouse_publish
```

Human FEA using [gprofiler](https://biit.cs.ut.ee/gprofiler/page/r)
```{r}
#input needs to be a dataframe with genes and p values, so each pattern will need its own dataframe
#sample_factors has already been extracted from AP_human, need to do the same with the stdev
human_feature <- as.data.frame(AP_human@featureLoadings)
human_feature_stdev <- as.data.frame(AP_human@loadingStdDev)
pattern5_human <- dplyr::select(human_feature, Pattern_5) %>% cbind(., StdDev = human_feature_stdev$Pattern_5)
head(pattern5_human)
pattern1_human <- dplyr::select(human_feature, Pattern_1) %>% cbind(., StdDev = human_feature_stdev$Pattern_1)
head(pattern1_human)

#want to look at just the significant genes of pattern 5
pattern5_sig <- pattern5_human[pattern5_human$StdDev < 0.1,]
pattern1_sig <- pattern1_human[pattern1_human$StdDev < 0.1,]

pattern5_human_names <- rownames(pattern5_sig) %>% as.list()
names(pattern5_human_names) <- rownames(pattern5_sig)
```

Subsetting human data differently
```{r}
human_feature_df <- rownames_to_column(human_feature, var = "Genes")
human_nmf_geneweight_long <- pivot_longer(data = human_feature_df, 
                         cols = -Genes,
                         names_to = "Pattern", 
                         values_to = "Gene_weight")
head(human_nmf_geneweight_long)

human_pattern2 <- human_nmf_geneweight_long %>% dplyr::filter( Pattern == "Pattern_2") %>% slice_max(order_by = Gene_weight, n = 150)
human_pattern5 <- human_nmf_geneweight_long %>% dplyr::filter( Pattern == "Pattern_5") %>% slice_max(order_by = Gene_weight, n = 150)
human_pattern9 <- human_nmf_geneweight_long %>% dplyr::filter( Pattern == "Pattern_9") %>% slice_max(order_by = Gene_weight, n = 150)

human_pattern2_names <- as.list(human_pattern2$Genes)
names(human_pattern2_names) <- human_pattern2$Genes

human_pattern5_names <- as.list(human_pattern5$Genes)
names(human_pattern5_names) <- human_pattern5$Genes

human_pattern9_names <- as.list(human_pattern9$Genes)
names(human_pattern9_names) <- human_pattern9$Genes

```

Human gprofiler gost() runs
```{r}
#look into exclude_iea and correction_methods
gost_res_2 <- gost(query =  human_pattern2_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("REAC", "KEGG", "CORUM"), as_short_link = FALSE)
head(gost_res_2$result)

gost_res_5 <- gost(query =  human_pattern5_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("REAC", "KEGG", "CORUM"), as_short_link = FALSE)
head(gost_res_5$result)

gost_res_9 <- gost(query =  human_pattern9_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("REAC", "KEGG", "CORUM"), as_short_link = FALSE)
head(gost_res_9$result)

```

Data wrangling for human alluvial point
```{r}
#need to add an identifier for pattern number for each dataframe
gost_pattern2 <- cbind(gost_res_2$result, pattern = c(rep("pattern_2")))
gost_pattern5 <- cbind(gost_res_5$result, pattern = c(rep("pattern_5")))
gost_pattern9 <- cbind(gost_res_9$result, pattern = c(rep("pattern_9")))


```

Human alluvial plot - Patterns 2, 5, and 9
```{r}
#combine dataframes
gost_pattern259_all <- rbind(gost_pattern2, gost_pattern5, gost_pattern9)
#looking at just kegg results
gost_pattern259 <- dplyr::filter(gost_pattern259_all, source == "KEGG")

#gost_pattern259_table <- apply(gost_pattern259, 2, as.character)
#write.csv2(gost_pattern259_table, file = "gost_human_results_patterns259.csv")
```

```{r fig.align="center", fig.width = 7}

ggalluvial_KEGG_259 <- ggplot(gost_pattern259,
       aes(axis1 = pattern, axis2 = term_name, y = query_size)) +
  geom_alluvium(aes(fill = term_name), width = 1/12) +
  geom_stratum(width = 1/24, fill = "black", color = "grey") +
 # geom_label(stat = "stratum", label.size = 0.15, aes(label = NULL, size = .5), nudge_x = -0.1) +
  scale_x_discrete(limits = c("Pattern", "Pathway"), expand = c(.05, .05)) +
  scale_colour_viridis_d(option = "magma") +
  labs(y = NULL) +
  theme(axis.text.x = element_text(size=14), axis.text.y = element_blank(), axis.title = element_text(size = 16), title = element_text(size = 18), legend.text = element_text(size = 14)) +
  theme(panel.grid = element_blank()) +
  theme(plot.margin = unit(c(1,.075,1,.5),"cm")) + #top, right, bottom, left
  guides(fill=guide_legend(title="KEGG Pathways"), col = guide_legend(nrow = 2)) + 
  ggtitle("Pre/Post Exercise-Associated \nPattern Pathways")
ggalluvial_KEGG_259

```


```{r eval=FALSE, include=FALSE}
ggsave("210706_human_patterns_259_kegg_alluvialplot_bigfont.pdf", ggalluvial_KEGG_259)
```

Alluvial Plot - Mouse  
Looking at all gost results and just KEGG/Reactome/Corum
```{r eval=FALSE, include=FALSE}
#combine pattern FEA data frames
#need to add an identifier for pattern number for each dataframe
gost_mouse_pattern4_top150gene_fea <- cbind(gost_mouse_pattern4_top150gene_fea, c(rep("pattern_4")))
gost_mouse_pattern5_top150gene_fea <- cbind(gost_mouse_pattern5_top150gene_fea, c(rep("pattern_5")))
gost_mouse_pattern6_top150gene_fea <- cbind(gost_mouse_pattern6_top150gene_fea, c(rep("pattern_6")))
mouse_patterns_4thru6 <- rbind(gost_mouse_pattern4_top150gene_fea, gost_mouse_pattern5_top150gene_fea, gost_mouse_pattern6_top150gene_fea)
mouse_patterns_4thru6 <- as.data.frame(mouse_patterns_4thru6) 
names(mouse_patterns_4thru6)[names(mouse_patterns_4thru6) == "V15"] <- "Pattern" 

#combining gost results for patterns 3:6 with just sources KEGG/Reactome/Corum
mouse_pattern3_rkc <- cbind(mouse_pattern3_rkc, pattern = c(rep("pattern_3")))
mouse_pattern4_rkc <- cbind(mouse_pattern4_rkc, pattern = c(rep("pattern_4")))
mouse_pattern5_rkc <- cbind(mouse_pattern5_rkc, pattern = c(rep("pattern_5")))
mouse_pattern6_rkc <- cbind(mouse_pattern6_rkc, pattern = c(rep("pattern_6")))
mouse_rkc_3thru6 <- rbind(mouse_pattern3_rkc, mouse_pattern4_rkc, mouse_pattern5_rkc, mouse_pattern6_rkc)

#ggalluvial <- ggplot(mouse_rkc_3thru6,
#       aes(axis1 = pattern, axis2 = term_name, y = term_size)) +
#  geom_alluvium(aes(fill = term_name), width = 1/12) +
#  geom_stratum(width = 1/12, fill = "black", color = "grey") +
#  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
#  scale_x_discrete(limits = c("Pattern", "Pathway"), expand = c(.05, .05)) +
#  scale_fill_brewer(type = "qual", palette = "Set3") +
#  ggtitle("Mouse Patterns to Pathways")
#ggalluvial
```


```{r eval=FALSE, include=FALSE}
ggsave("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210616_gprofiler_mouse_patterns3thru6_FEA_sources_alluvial.pdf", ggalluvial)

```

Alluvial Plot - Mouse  
Looking just at gost profiler KEGG results
```{r eval=FALSE, include=FALSE}
mouse_KEGG_3thru6 <- dplyr::filter(mouse_rkc_3thru6, source == "KEGG")

ggalluvial_KEGG <- ggplot(mouse_KEGG_3thru6,
       aes(axis1 = pattern, axis2 = term_name, y = query_size)) +
  geom_alluvium(aes(fill = term_name), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("Pattern", "Pathway"), expand = c(.05, .05)) +
  scale_colour_viridis_d(option = "inferno") +
  ggtitle("Mouse Patterns to Pathways")
ggalluvial_KEGG

```

```{r eval=FALSE, include=FALSE}
ggsave("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210617_gprofiler_mouse_patterns3thru6_KEGG_alluvial.pdf", ggalluvial_KEGG)
```

Alluvial Plot - Mouse  
Looking just at gost profiler GO results
```{r eval=FALSE, include=FALSE}
#combining gost results for patterns 3:6 with just GO sources
mouse_pattern3_GO <- cbind(mouse_pattern3_GO, pattern = c(rep("pattern_3")))
mouse_pattern4_GO <- cbind(mouse_pattern4_GO, pattern = c(rep("pattern_4")))
mouse_pattern5_GO <- cbind(mouse_pattern5_GO, pattern = c(rep("pattern_5")))
mouse_pattern6_GO <- cbind(mouse_pattern6_GO, pattern = c(rep("pattern_6")))
mouse_GO_3thru6 <- rbind(mouse_pattern3_GO, mouse_pattern4_GO, mouse_pattern5_GO, mouse_pattern6_GO)

ggalluvial_GO <- ggplot(mouse_GO_3thru6,
       aes(axis1 = pattern, axis2 = source, y = term_size)) +
  geom_alluvium(aes(fill = source), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("Pattern", "Pathway"), expand = c(.05, .05)) +
  scale_fill_brewer(type = "qual", palette = "Set1") +
  ggtitle("Mouse Patterns to Pathways")
ggalluvial_GO
```


```{r eval=FALSE, include=FALSE}
ggsave("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210616_gprofiler_mouse_patterns3thru6_FEA_GOsources_alluvial.pdf", ggalluvial_GO)

```

### Versions  
```{r}
installed.packages()[names(sessionInfo()$otherPkgs), "Version"]
``` 