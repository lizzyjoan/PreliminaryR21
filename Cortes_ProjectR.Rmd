---
title: "ProjectR"
author: "Lizzy Ramsey"
date: "4/26/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(projectR)
library(CoGAPS)
library(ggplot2)
library(DESeq2)
library(gplots)
library(dplyr)
library(tibble)
library(AnnotationDbi)
library(devtools)
library(ggbiplot)
library(biomaRt)
library(tidyr)
library(ggalluvial)
library(ggrepel)
library(gprofiler2)
library(EnsDb.Hsapiens.v86)
library(viridis)
```

### Purpose
Publicly available mouse and human datasets of pre/post gene expression in skeletal muscle were used to project mouse patterns onto human data using ProjectR package. The end goal is to find latent variables in mouse gene expression to project onto human data to make mouse data better recapitulate human data.
Built with r getRversion()

  
**Overview**  
Step 1: Load packages  
Step 2: Read in RNAseq raw counts  
Step 3: Normalize using DESeq2  
Step 4: PCA of mouse data  
Step 5: Convert mouse Ensembl gene ID's to symbols  
Step 6: Convert mouse symbols to human symbols  
Step 7: NMF method and visualization
Step 8: PCA method and visualization
Step 9: Clustering method and visualization (in progress)
Step 10: Functional enrichment analysis (in progress)
  
**Data**  
Mouse Data: *GSE97718*  
- fastq's downloaded from ENA  
- data preprocessed with RNA-seq STAR pipeline by Lara Ianov  
  
Human Data: *GSE108643*  
- fastq's downloaded from ENA  
- data preprocessed with RNA-seq STAR pipeline by Lara Ianov  
  
**Read in Mouse Data**  
```{r, copy = TRUE}
#Load in raw counts for Mouse pre/post exercise experiment
mouse_counts <- read.delim("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/mouse210321_fixed_raw_counts.txt", header = TRUE, row.names = 1, sep = "\t", stringsAsFactors = FALSE)
mouse_counts <- mouse_counts[, -c(1:3)]
```


**Make Mouse Metadata Table**  
Metadata/info table not supplied with this study. Using GEO, manually created (see here *https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE97718*)
```{r}
#metadata not included with this dataset.. 
mouse_info <- read.csv("MouseSraRunTable.txt", header = TRUE, sep = ",")
Name <- c("CON_pre4","HFD_pre2","HFD_pre3","HFD_pre4","CON_post1","CON_post2","CON_post3","CON_post4","HFD_post4","CON_pre3","CON_pre2","HFD_post2","HFD_post3","HFD_pre1","CON_pre1","HFD_post1")
mouse_info <- cbind(mouse_info, Name)
#making columns specific to condition (diet and exercise)
mouse_info <- mutate(mouse_info, Diet = ifelse(grepl("HFD", Name, ignore.case = TRUE), "HFD", "CON"))
mouse_info <- mutate(mouse_info, Exercise = ifelse(grepl("pre", Name, ignore.case = TRUE), "pre", "post"))
mouse_info <- column_to_rownames(mouse_info, var = "Name")

```

**Read in Human Data** 
```{r}
#HUMAN data read in
human_data <- read.delim("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/human_fixed_raw_counts.txt", header = TRUE, row.names = 1, sep = "\t")
human_data <- human_data[, -c(1:3)]
human_info <- read.csv("human_info.csv", header = TRUE, sep = ",")
human_info <- human_info[c(1:58),]
#make new label names for human samples
human_info_test <- unite(human_info, col = Name, BMI, PrePost, sep = "_", remove = FALSE)
##NEED TO FIGURE OUT how to add sequence of 1-3 for every 3 columns to give unique names
#human_info_test <- lapply(human_info_test$Name, c(1:3), paste())
#rep(1:14, 4) and then paste0
numbered_list <- c(1:14, 1:15, 1:14, 1:15)
names <- paste(human_info_test$Name, numbered_list, sep = "_")
human_info_test[["Names"]] <- names
human_info <- column_to_rownames(human_info_test, var = "Names")

```

**DESeq2 for Mouse**  
DESeq2 was used to normalize data  

```{r, message=FALSE}
mouse_dds <- DESeqDataSetFromMatrix(mouse_counts, colData = mouse_info, design = ~ Exercise)
mouse_dds <- DESeq(mouse_dds)
#Contrast for log fold change, pre = numerator, post = denominator
mouse_res <- results(mouse_dds, contrast = c("Exercise", "post", "pre"))
write.csv(as.data.frame(mouse_res), file = "Mouse_DESeq2_results.csv")

mouse_vsd <- vst(mouse_dds, blind = FALSE)
```


```{r}
mouse_deseq2_pca <- DESeq2::plotPCA(mouse_vsd, intgroup = "Exercise", )
mouse_deseq2_pca
```

**DESeq2 for Human**  
DESeq2 was used to normalize data  

```{r, message = FALSE}
#HUMAN normalization
human_dds <- DESeqDataSetFromMatrix(human_data, colData = human_info, design = ~ PrePost)
human_dds <- DESeq(human_dds)
human_res <- results(human_dds, contrast = c("PrePost", "Post", "Pre"))
write.csv(human_res, file = "210518_Human_DESeq_Res.csv")
human_vsd <- vst(human_dds, blind = FALSE)

# trying to get lfc in order
human_de <- cbind(LFC = human_res$log2FoldChange, Pval = human_res$pvalue)
row.names(human_de) <- row.names(human_res)
human_de_df <- as.data.frame(human_de)
human_de_ordered <- human_de_df[order(-human_de_df$LFC), , drop = FALSE]
```

```{r, message = FALSE}
human_vsd_matrix <- assay(human_vsd)
human_deseq2_pca <- plotPCA(human_vsd, intgroup = "PrePost")
human_deseq2_pca
rownames(human_vsd_matrix) <- sub("\\..*", "", rownames(human_vsd_matrix))
#back to df and make ensembl gene rownames into a column
human_vsd_matrix <- human_vsd_matrix %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")
```

**Mouse Gene ID Conversion**  
```{r}
#preparing outputs for conversion
mouse_vsd_matrix <- assay(mouse_vsd)
rownames(mouse_vsd_matrix) <- sub("\\..*", "", rownames(mouse_vsd_matrix))
mouse_vsd2 <- mouse_vsd_matrix %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")
write.csv(mouse_info, file= "New_Mouse_Metadata")

```

**AnnotationDbi for Mouse Symbols**  

```{r, message=FALSE}
#annotation
library(org.Mm.eg.db)
#retrieve conversion info from one ID type to another
#REPLACE test_mouse to mouse_anno
mouse_anno <- AnnotationDbi::select(org.Mm.eg.db, keys = rownames(mouse_vsd_matrix), columns = c("SYMBOL", "GO"),keytype = "ENSEMBL")
#determine indices for non-NA genes
mousenon_na_symbols <- which(is.na(mouse_anno$SYMBOL) == FALSE)
#return only the genes with annotations using indices
mouse_anno <- mouse_anno[mousenon_na_symbols, ]
#determine indices for non-duplicated genes
mouseno_dups_symbols <- which(duplicated(mouse_anno$SYMBOL) == FALSE)
#return only non-dup genes using indices
mouse_anno <- mouse_anno[mouseno_dups_symbols, ]
#add symbols to normalized mouse data
mouse_symbol <- inner_join(mouse_anno, mouse_vsd2, by = "ENSEMBL")
#has GO annotation as well as the other gene ID info
mouse_symbol_GO <- column_to_rownames(mouse_symbol, var = "SYMBOL")
#removing annotations, symbols for row names, format for analysis
mouse_symbol <- mouse_symbol_GO[,c(5:20)]

```

**AnnotationDbi for Human Symbols**  

```{r}
#annotation
BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
#retrieve conversion info from one ID type to another
symbols_human <- AnnotationDbi::select(org.Hs.eg.db, keys = human_vsd_matrix$ENSEMBL, columns = c("SYMBOL", "GO"),keytype = "ENSEMBL")
#determine indices for non-NA genes
non_na <- which(is.na(symbols_human$SYMBOL) == FALSE)
#return only the genes with annotations using indices
symbols_human <- symbols_human[non_na, ]
#determine indices for non-duplicated genes
no_dups_human <- which(duplicated(symbols_human$SYMBOL) == FALSE)
#return only non-dup genes using indices
symbols_human <- symbols_human[no_dups_human, ]
human_symbol_data <- inner_join(symbols_human, human_vsd_matrix, by = "ENSEMBL")
#has GO annotation as well as the other gene ID info
human_symbol_data_GO <- column_to_rownames(human_symbol_data, var = "SYMBOL")
#removing annotations, symbols for row names, format for analysis
human_symbol_data <- human_symbol_data_GO[,5:62]

```

**Convert from mouse to human orthologous symbols**  
To be able to compare gene expression data from mouse to human, must convert first to orthologous genes

```{r}
## Basic function to convert mouse to human gene names
convertMouseGeneList <- function(x){
require("biomaRt")
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
genesV2 = getLDS(attributes = c("mgi_symbol"), filters = "mgi_symbol", values = x , mart = mouse, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=T)
return(genesV2)
}

```


```{r}
#Use convertMouseGeneList to convert to human genes
mouse_to_human_genes <- convertMouseGeneList(mouse_anno$SYMBOL)
conv_mouse <- mouse_symbol %>% rownames_to_column(., var = "MGI.symbol") %>% left_join(., mouse_to_human_genes, by = "MGI.symbol")
#determine non-NA genes
non_na_mouse <- which(is.na(conv_mouse$HGNC.symbol) == FALSE)
#return only the genes with annotations using indices
conv_mouse <- conv_mouse[non_na_mouse, ]
#determine indices for non-duplicated genes
no_dups_mouse <- which(duplicated(conv_mouse$HGNC.symbol) == FALSE)
#return only non-dup genes using indices
conv_mouse <- conv_mouse[no_dups_mouse, ]
rownames(conv_mouse) <- NULL 
conv_mouse <- conv_mouse %>% as.data.frame() %>% column_to_rownames(., var = "HGNC.symbol") 
conv_mouse <- conv_mouse[,c(2:17)]

```

**ProjectR NMF Using CoGAPS for Mouse**  
How many patterns? Might need to finish FEA to figure out. 
```{r}
#MOUSE NMF
#parameters for GoGAPS
params <- new("CogapsParams")
params <- setParam(params, "seed", 1000)
params <- setParam(params, "nPatterns", 12)

```

```{r}
#chisq_matrix <- matrix(data = 0, nrow = 9, ncol = 10)
#row.names(chisq_matrix) <- c(7:15)
#colnames(chisq_matrix) <- c(1000, 3000, 5000, 6000, 7000, 8000, 10000, 12000, 15000, 25000, 30000, 35000)
```

```{r}
#CoGAPS to find patterns in the data
#set parameters for number of patterns
params <- setParam(params, "nPatterns", pattern[i])

AP_mouse <- CoGAPS(conv_mouse, params, nIterations = 5000)
chisq_matrix[9,9] <- getMeanChiSq(AP_mouse)


#for loop
#patterns 7:15 , iterations 1000, 3000, 5000, 6000, 7000, 8000, 10000, 12000, 15000
n_patterns <- c(7:15)
n_iterations <- c(1000, 3000, 5000, 6000, 7000, 8000, 10000, 12000, 15000)

get_chisq <- function(patterns, iterations) {
  chisq_matrix <- matrix(data = 0, nrow = 9, ncol = 9)
  params <- new("CogapsParams")
  params <- setParam(params, "seed", 1000)
  
  for (i in 1:length(patterns)) {
    params <- setParam(params, "nPatterns", patterns[i])
    for (j in 1:length(iterations)){
      AP <- CoGAPS(conv_mouse, params, nIterations = iterations[j])
      chi_sq <- getMeanChiSq(AP)
      chisq_matrix[i,j] <- chi_sq
  }
}
  return(chisq_matrix)
}

get_chisq(n_patterns, n_iterations)

write.csv2(chisq_matrix, file = "/Users/eramsey/Desktop/R21_210302/PreliminaryR21/mouse_chisq_matrix.csv")
#chisq_matrix
#best is 5000 iterations, 11 patterns

#chisq_df <- as.data.frame(chisq_matrix)
#ggplot(as.data.frame(chisq_matrix)) + aes(x = 1000, y = c(7:15)) + geom_line()
#scatter.smooth(chisq_matrix)
#plot(chisq_df, 1000, type = "b")

#plot(AP_mouse)


```
**ProjectR NMF Using CoGAPS for Human**  

```{r}
#CoGAPS to find patterns in the data
AP_human <- CoGAPS(human_symbol_data, params, nIterations = 6000)
getMeanChiSq(AP_human)
plot(AP_human)
```

Boxplot for Patterns in Mouse
```{r}
mouse_samplefactors <- AP_mouse@sampleFactors %>% as.data.frame() 
#%>% rownames_to_column(., var = "Sample")
mouse_samplefactors <- cbind(mouse_samplefactors, Exercise = mouse_info$Exercise)

exercisefactors <- as.numeric(factor(mouse_samplefactors$Exercise)) 
mouse_samplefactors_split <- cbind(mouse_samplefactors, ExerciseFactors = exercisefactors)
mouse_samplefactors_split <- subset(mouse_samplefactors_split, select = -Exercise)
#mouse_samplefactors_split <- split(mouse_samplefactors, mouse_samplefactors$ExerciseFactors)
#mouse_samplefactors <- as.data.frame(mouse_samplefactors)

#Struggling with ggplot
#mouse_boxplot <- ggplot(mouse_samplefactors, aes(x = Exercise, y = Pattern_2)) + geom_boxplot()
#mouse_boxplot

baseboxplot <- 
boxplot(mouse_samplefactors_split, xlab = "NMF Patterns", ylab = "Sample Weights", las = 2, main = "Sample Factors", subset = mouse_samplefactors_split$ExerciseFactors == 2, col = "red")
boxplot(mouse_samplefactors_split, las = 2, subset = mouse_samplefactors_split$ExerciseFactors == 1, col = "blue", add = TRUE)
#did not work

#try splitting into two matrices, pre and post, and then use add to "add boxplot to current plot"

#try grouping pre/post exercise into two different matrices, and then combine them into a boxplot
pre_exercise <- filter(mouse_samplefactors, Exercise == "pre")
pre_exercise <- subset(pre_exercise, select = -Exercise)
post_exercise <- filter(mouse_samplefactors, Exercise == "post")
post_exercise <- subset(post_exercise, select = -Exercise)
#base r boxplot
boxplot_factors_post <- boxplot(post_exercise, las = 2, ylab = "Sample Factors", main = "Mouse Post Exercise Patterns", col = "powderblue")
#add data points
stripchart(post_exercise, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black')
boxplot_factors_pre <- boxplot(pre_exercise, las = 2, ylab = "Sample Factors", main = "Mouse Pre Exercise Patterns", col = "plum2")
stripchart(pre_exercise, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black')
```

Violin Plots
```{r}
mouse_long_pre <- pre_exercise %>% gather(key = "Patterns", value = "Val") %>% ggplot( aes(x = Patterns, y = Val, fill = Patterns)) + geom_violin()
mouse_long_pre
```


```{r}
mouse_long_post <- post_exercise %>% gather(key = "Patterns", value = "Val") %>% ggplot( aes(x = Patterns, y = Val, fill = Patterns)) + geom_violin()
mouse_long_post
```



```{r}
mouse_featureLoadings <- AP_mouse@featureLoadings %>% as.data.frame() 
boxplot_loadings <- boxplot(mouse_featureLoadings, xlab = "NMF Patterns", ylab = "Amplitude", las = 2, main = "Mouse Feature Loadings")


```
 Boxplot for Patterns in Human
```{r}
human_samplefactors <- AP_human@sampleFactors %>% as.data.frame() 
#%>% rownames_to_column(., var = "Sample")
human_samplefactors <- cbind(human_samplefactors, Exercise = human_info$PrePost)

#exercisefactors_human <- as.numeric(factor(human_samplefactors$Exercise)) 
#human_samplefactors_split <- cbind(human_samplefactors, ExerciseFactors = exercisefactors)
#human_samplefactors_split <- subset(human_samplefactors_split, select = -Exercise)

#mouse_samplefactors_split <- split(mouse_samplefactors, mouse_samplefactors$ExerciseFactors)
#mouse_samplefactors <- as.data.frame(mouse_samplefactors)

#Struggling with ggplot
#mouse_boxplot <- ggplot(mouse_samplefactors, aes(x = Exercise, y = Pattern_2)) + geom_boxplot()
#mouse_boxplot

#baseboxplot <- 
#boxplot(mouse_samplefactors_split, xlab = "NMF Patterns", ylab = "Sample Weights", las = 2, main = "Sample Factors", subset = mouse_samplefactors_split$ExerciseFactors == 2, col = "red")
#boxplot(mouse_samplefactors_split, las = 2, subset = mouse_samplefactors_split$ExerciseFactors == 1, col = "blue", add = TRUE)
#did not work

#try splitting into two matrices, pre and post, and then use add to "add boxplot to current plot"

#try grouping pre/post exercise into two different matrices, and then combine them into a boxplot
pre_exercise_human <- filter(human_samplefactors, Exercise == "Pre")
pre_exercise_human <- subset(pre_exercise_human, select = -Exercise)
post_exercise_human <- filter(human_samplefactors, Exercise == "Post")
post_exercise_human <- subset(post_exercise_human, select = -Exercise)
#base r boxplot
boxplot_factors_post_human <- boxplot(post_exercise_human, las = 2, ylab = "Sample Factors", main = "Human Post Exercise Patterns", col = "powderblue")
#add data points
stripchart(post_exercise_human, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black')
boxplot_factors_pre_human <- boxplot(pre_exercise_human, las = 2, ylab = "Sample Factors", main = "Human Pre Exercise Patterns", col = "plum2")
stripchart(pre_exercise_human, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'black')
```
 
 
**Heatmap of Mouse NMF**  
Visualizing NMF object
```{r}
#heatmap
#Error in plot.new() : figure margins too large
#trying par(mar) to change margins

#NMF_mouse <-heatmap.2(as.matrix(AP_mouse),col=bluered, trace='none',
#                 distfun=function(c) as.dist(1-cor(t(c))) ,
#                 cexCol=1,cexRow=.6,scale = "row", main = "Mouse Data: nPatterns 14, nIterations #5000", labRow = rownames(conv_mouse), xlab = "Patterns",
#                 hclustfun=function(x) hclust(x, method="average"))
#pdf("NewMouse_NMF_nPat14_nIt5000.pdf", NMF_mouse)
#NMF_mouse
```


**NMF Projection**  
The mouse NMF patterns can then be projected onto the human data
```{r}
#NMF to project into PC's from mouse expression data
human_data <- as.matrix(human_symbol_data)
human_NMF <- projectR(human_data,loadings=AP_mouse, full=TRUE,
                     dataNames=rownames(human_data))

#Using metadata and NMF projection to make a dataframe that can be plotted
#human_meta <- column_to_rownames(human_info, var = "SRR")
#dNMF <- human_NMF %>% data.frame() %>% t() %>% cbind(., )
projection_NMF <- human_NMF$projection %>% t() %>% cbind(., human_info)
pval_NMF <- human_NMF$pval
#plot pca
projection_plot <- ggplot(projection_NMF, aes(x = Pattern_3, y = Pattern_5, colour = PrePost)) + geom_point() + ggtitle("Mouse Data NMF Patterns Projected onto Human Data")
projection_plot
ggsave("NMF_Mouse_Projected_to_Human_14pat5000it.pdf", projection_plot)


```

**PC Projection**  
Another method to projections. Principal components are found for mouse and human data. Mouse PC's are used for loadings and projected onto human data.  
  
Make PC's
```{r}
pc_human <- prcomp(t(human_symbol_data))
pc_mouse <- prcomp(t(conv_mouse))
#find variance
pc_var_mouse <- round(((pc_mouse$sdev)^2/sum(pc_mouse$sdev^2))*100,2)
pca_mouse_df <- data.frame(cbind(pc_mouse$x, mouse_info))

```
  
Project PC's
```{r}
PCA_projectr <- projectR(human_data, loadings = pc_mouse, full = TRUE, dataNames = rownames(human_data))
human_meta_t <- t(human_meta)
PCA_projectr_t <- t(PCA_projectr[[1]])
PCA_projectr_df <- cbind(PCA_projectr_t, human_meta)
#[1] "18282 row names matched between data and loadings"
#[1] "Updated dimension of data: 18282 58"

#Plot PCA
dPCA <- data.frame(cbind(t(PCA_projectr[[1]]),PCA_projectr_df))
projected_PCA <- ggplot(PCA_projectr_df, aes(x = PC1, y = PC2, colour = PrePost)) + geom_point() +  ggtitle("Mouse Principal Components Projected onto Human Data")
projected_PCA
ggsave("PCA_Method_Mouse_Projected_onto_Human.pdf", projected_PCA)
```



**ProjectR Clustering Method**  
There’s 2 methods: cluster2pattern finds correlation of each gene’s expression by mean of cluster to define continuous weights. Then intersector tests significant overlap between 2 clustering objects. For these purposes, I think cluster2pattern is better for finding what we want (differences between clusters rather than overlaps). Requires a clustering object first.
```{r, message = FALSE}
#TOP 50 DIFFERENTIALLY EXPRESSED GENES
#error "the standard deviation is zero" for cluster2pattern
#checking standard deviation for each gene
stdevs <- apply(conv_mouse, 1, sd)
mouse_stdev <- cbind(conv_mouse, stdevs)
mouse_stdev <- slice_max(mouse_stdev, order_by = stdevs, n = 250)
mouse_top250 <- mouse_stdev[,-17]
write.csv2(mouse_top250, file = "Mouse_Top250_DEG.csv")
```

```{r}
library(fpc)
#pamk: partitioning around medoids clustering with the number of clusters estimated by optimum average silhouette width 
#part_clust_mouse <- pamk(stdevs, scaling = TRUE)
#plot(part_clust_mouse$pamobject)

#  Hierarchical Clustering
mouse_dist <- dist(mouse_top250, method = "euclidean") # distance matrix 
hclust_fit <- hclust(mouse_dist, method="average")
plot(hclust_fit) # display dendrogram
#looks like 3 clusters would be best 
```

```{r}
#  Hierarchical Clustering with Bootstrapped p values
library(pvclust)
#pvclust() provides p-values for hierarchical clustering based on multiscale bootstrap resampling-clusters that are highly supported by the data will have large p values.
#pvclust clusters columns, not rows: transpose your data before using
fit <- pvclust(mouse_top50, method.hclust="average",
   method.dist="euclidean")
hclust_dendro_sig <- plot(fit) 
pvrect(fit, alpha=.90) # add rectangles around groups highly supported by the data


pdf(file = "Mouse_Hclust_Dendrogram.pdf", hclust_dendro_sig)

#clusterplotR... what is this/how to use this/should I use this?
#mouse_clusterplotr <- clusterPlotR(mouse_top50, hclust_fit, NC = 3)
```


**Clustering in Human Data**  
```{r}
#TOP 50 DIFFERENTIALLY EXPRESSED GENES
human_stdevs <- apply(human_symbol_data, 1, sd)
human_stdev <- cbind(human_symbol_data, human_stdevs)
human_stdev <- slice_max(human_stdev, order_by = human_stdevs, n = 50)
human_top250 <- human_stdev[,-17]
write.csv2(human_top250, file = "Human_Top50_DEG.csv")

#  Hierarchical Clustering with Bootstrapped p values
#pvclust() provides p-values for hierarchical clustering based on multiscale bootstrap resampling-clusters that are highly supported by the data will have large p values.
#pvclust clusters columns, not rows: transpose your data before using

fit_human <- pvclust(human_top250, method.hclust="average",
   method.dist="euclidean")
human_hclust_dendro_sig <- plot(fit_human) 
#pvrect(fit, alpha=.90) # add rectangles around groups highly supported by the data

#pdf(file = "Mouse_Hclust_Dendrogram.pdf", hclust_dendro_sig)

##LETSDOAHEATMAP!! :) 

```


Output of the cluster2pattern function is a pclust class object; specifically, a matrix of
genes (rows) by clusters (columns). A gene’s value outside of its assigned cluster is zero. For
the cluster containing a given gene, the gene’s value is the corelation of the gene’s expression
to the mean of that cluster.
```{r}

#output of the cluster2pattern function is a pclust class object; specifically, a matrix of
#genes (rows) by clusters (columns). A gene’s value outside of its assigned cluster is zero. For
#the cluster containing a given gene, the gene’s value is the corelation of the gene’s expression
#to the mean of that cluster.
mouse_clusters <- cluster2pattern(hclust_fit, NP = 2, Data = mouse_top250)

cluster_plot <- ggplot(as.data.frame(mouse_clusters), aes(x = V1, y = V2, label = rownames(mouse_clusters))) + geom_point() + ggtitle("Mouse Clusters") + geom_text_repel()
cluster_plot

#join these genes to their GO terms? 
#mouse_clusters_GO <- left_join()
#mouse_clusterplot <- clusterPlotR(cdata = mouse_top50, cls = hclust_fit, NC = 1, mouse_info$Exercise)
#Error in matrix(ncol = dim(cData)[2], nrow = length(cls1)) : non-numeric matrix extent
```

Projecting mouse clusters onto human data
```{r}
#need to use the top 50 genes from mouse DE to pull those genes from human and then project cluster object from cluster2pattern onto human data 
top50_list <- rownames_to_column(mouse_top50, var = "SYMBOL")
human_list <- rownames_to_column(human_symbol_data_GO, var = "SYMBOL")
top50_list <- semi_join(human_list, top50_list, by = "SYMBOL")
mouseToHumanTop50 <- column_to_rownames(top50_list, var = "SYMBOL")
mouseToHumanTop50 <- mouseToHumanTop50[,5:62]
mouseToHumanTop50 <- as.matrix(mouseToHumanTop50)

```


```{r}
cluster_projection <- projectR(mouseToHumanTop50, loadings = mouse_clusters, full = TRUE, dataNames = rownames(mouseToHumanTop50))
#combining projection with metadata and preparing for PCA
cluster_projection_t <- t(cluster_projection[[1]])
cluster_projection_df <- cbind(cluster_projection_t, human_meta)
cluster_projection_plot <- ggplot(cluster_projection_df, aes(x = x1, y = x2, colour = PrePost)) + geom_point() + ggtitle("Mouse Clusters Projected onto Human Data")
cluster_projection_plot
ggsave("Mouse_Clusters_Projection.pdf", cluster_projection_plot)

```

## Using Differentially Expressed Genes for Functional Enrichment Analysis ##

**AnnotationDbi for DESeq2 Mouse Results**  

```{r, message=FALSE}
#Pull DESeq2 results for LFC and P-values, get rid of decimals in ensembl ID's
mouse_de <- cbind(LFC = mouse_res$log2FoldChange, Pval = mouse_res$pvalue)
row.names(mouse_de) <- row.names(mouse_res)
rownames(mouse_de) <- sub("\\..*", "", rownames(mouse_de))
mouse_de_df <- mouse_de %>% as.data.frame() %>% rownames_to_column(., "ENSEMBL")

```

```{r}
#Join annotations to DE gene list
mouse_symbol_de <- inner_join(mouse_anno, mouse_de_df, by = "ENSEMBL")
mouse_symbol_GO_de <- column_to_rownames(mouse_symbol_de, var = "SYMBOL")
#This table has ensembl gene ID's, GO info, differential expression and p-values
write.csv(mouse_symbol_GO_de, "Mouse_DE_GO.csv")
#Only need LFC and p-values for FEA
mouse_symbol_de <- mouse_symbol_GO_de[,c(5,6)]
```




Might try to visualize using UMAP (Uniform Manifold Approximation and Projection)
```{r}

#library(umap)
#mouse_umap <- umap(mouse_DE_top50)

```
```{r}
#Gene weights by latent variables
#mouse_geneweights <- AP_mouse@loadingStdDev
#mouse_geneweights2 <- rownames_to_column(as.data.frame(mouse_geneweights), var = "SYMBOL")
#mouse_go2 <- rownames_to_column(mouse_symbol_GO, var = "SYMBOL")
#mouse_weightgo <- left_join(mouse_geneweights2, mouse_go2, by = "SYMBOL")
##NOTICED: mouse_go has not been converted to human .. 

#mouse_geneweights_matrix <- rownames_to_column(., var = "") left_join(mouse_geneweights )

```

**Functional Enrichment Analysis**  

GO (attempt)
```{r}
#Look at GO first
#first, use annotation dbi with AP_mouse@featureLoadings
#mouse_fea
#amp_anno <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(mouse_featureLoadings), columns = c("GO"), keytype = "SYMBOL")
  #mouse_featureLoadings
#returns multiple ontology terms for each gene... Not sure how to decide which to keep 

```

Mouse ggprofiler https://biit.cs.ut.ee/gprofiler/page/r
```{r}
#input needs to be a dataframe with genes and p values, so each pattern will need its own dataframe
#sample_factors has already been extracted from AP_human, need to do the same with the stdev
mouse_feature <- as.data.frame(AP_mouse@featureLoadings)
mouse_feature_stdev <- as.data.frame(AP_mouse@loadingStdDev)
pattern3_mouse <- dplyr::select(mouse_feature, Pattern_3) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_3)
head(pattern3_mouse)
pattern1_mouse <- dplyr::select(mouse_feature, Pattern_1) %>% cbind(., StdDev = mouse_feature_stdev$Pattern_1)
head(pattern2_mouse)

#want to look at just the significant genes of pattern 5
pattern3_sig_mouse <- pattern3_mouse[pattern3_mouse$StdDev < 0.05,]
pattern1_sig_mouse <- pattern1_mouse[pattern1_mouse$StdDev < 0.05,]
#narrow down significant genes list by selecting the highest weighted genes
#pattern3_sig_mouse <- slice_max(pattern3_sig_mouse, order_by = Pattern_3, n = 150)
#pattern2_sig_mouse <- slice_max(pattern2_sig_mouse, order_by = Pattern_2, n = 150)

#named list so genes names are retained and not changed to query_1 from gost()
#pattern3_sig_mouse <- as.list(pattern3_sig_mouse, all.names = TRUE)
pattern3_mouse_names <- rownames(pattern3_sig_mouse) %>% as.list()
names(pattern3_mouse_names) <- rownames(pattern3_sig_mouse)
pattern1_mouse_names <- rownames(pattern1_sig_mouse) %>% as.list()
names(pattern1_mouse_names) <- rownames(pattern1_sig_mouse)
```


```{r}
#look into exclude_iea and correction_methods
gost_res_mouse <- gost(query = pattern6_mouse_names, organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = c("GO:CC", "GO:BP", "GO:MF"), as_short_link = FALSE)
head(gost_res_mouse$result)
gost_res_mouse$result

#mouse_pattern5_rkc <- gost_res_mouse$result
mouse_pattern6_GO <- gost_res_mouse$result

gost_mouse_pattern3_top150gene_fea <- gost_res_mouse$result
#conversion to make this dataframe writable for csv
gost_mouse_pattern6_top150gene_fea <- apply(gost_mouse_pattern6_top150gene_fea,2,as.character)
write.csv2(gost_mouse_pattern6_top150gene_fea, file =  "/Users/eramsey/Desktop/R21_210302/PreliminaryR21/gost_mouse_pattern6_top150gene_fea.csv")

#most significant pathways
pattern3_sig_mouse_bp <- slice_min(gost_res_mouse$result, order_by = p_value, n = 20)
pattern3_sig_mouse_bp
```

```{r}
#GO:0005737 , GO:0005515 , GO:0071840
gost_plot_mouse <- gostplot(gost_res_mouse, capped = TRUE, interactive = FALSE)
gost_plot_mouse
```


```{r}
#top GO terms 
gost_mouse_publish <- publish_gostplot(gost_plot_mouse, highlight_terms = c("GO:0005737", "GO:0005515", "GO:0071840"), filename = "/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210614_gost_mouse_publishplot.pdf" ) 

gost_mouse_publish
```

Human ggprofiler https://biit.cs.ut.ee/gprofiler/page/r
```{r}
#input needs to be a dataframe with genes and p values, so each pattern will need its own dataframe
#sample_factors has already been extracted from AP_human, need to do the same with the stdev
human_feature <- as.data.frame(AP_human@featureLoadings)
human_feature_stdev <- as.data.frame(AP_human@loadingStdDev)
pattern5_human <- dplyr::select(human_feature, Pattern_5) %>% cbind(., StdDev = human_feature_stdev$Pattern_5)
head(pattern5_human)
pattern1_human <- dplyr::select(human_feature, Pattern_1) %>% cbind(., StdDev = human_feature_stdev$Pattern_1)
head(pattern1_human)

#want to look at just the significant genes of pattern 5
pattern5_sig <- pattern5_human[pattern5_human$StdDev < 0.1,]
pattern1_sig <- pattern1_human[pattern1_human$StdDev < 0.1,]

pattern5_human_names <- rownames(pattern5_sig) %>% as.list()
names(pattern5_human_names) <- rownames(pattern5_sig)
```

```{r}
#look into exclude_iea and correction_methods
gost_res <- gost(query = rownames(pattern3_), organism = "hsapiens", ordered_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = NULL, as_short_link = FALSE)
head(gost_res$result)

gost_plot <- gostplot(gost_res, capped = TRUE, interactive = TRUE)
gost_plot
gost_plot2 <- gostplot(gost_res, capped = FALSE, interactive = FALSE)
gost_plot2
```


Alluvial Plot - Mouse  
Looking at all gost results and just KEGG/Reactome/Corum
```{r}
#combine pattern FEA data frames
#need to add an identifier for pattern number for each dataframe
gost_mouse_pattern4_top150gene_fea <- cbind(gost_mouse_pattern4_top150gene_fea, c(rep("pattern_4")))
gost_mouse_pattern5_top150gene_fea <- cbind(gost_mouse_pattern5_top150gene_fea, c(rep("pattern_5")))
gost_mouse_pattern6_top150gene_fea <- cbind(gost_mouse_pattern6_top150gene_fea, c(rep("pattern_6")))
mouse_patterns_4thru6 <- rbind(gost_mouse_pattern4_top150gene_fea, gost_mouse_pattern5_top150gene_fea, gost_mouse_pattern6_top150gene_fea)
mouse_patterns_4thru6 <- as.data.frame(mouse_patterns_4thru6) 
names(mouse_patterns_4thru6)[names(mouse_patterns_4thru6) == "V15"] <- "Pattern" 

#combining gost results for patterns 3:6 with just sources KEGG/Reactome/Corum
mouse_pattern3_rkc <- cbind(mouse_pattern3_rkc, pattern = c(rep("pattern_3")))
mouse_pattern4_rkc <- cbind(mouse_pattern4_rkc, pattern = c(rep("pattern_4")))
mouse_pattern5_rkc <- cbind(mouse_pattern5_rkc, pattern = c(rep("pattern_5")))
mouse_pattern6_rkc <- cbind(mouse_pattern6_rkc, pattern = c(rep("pattern_6")))
mouse_rkc_3thru6 <- rbind(mouse_pattern3_rkc, mouse_pattern4_rkc, mouse_pattern5_rkc, mouse_pattern6_rkc)

ggalluvial <- ggplot(mouse_rkc_3thru6,
       aes(axis1 = pattern, axis2 = term_name, y = term_size)) +
  geom_alluvium(aes(fill = term_name), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("Pattern", "Pathway"), expand = c(.05, .05)) +
  scale_fill_brewer(type = "qual", palette = "Set3") +
  ggtitle("Mouse Patterns to Pathways")
ggalluvial
```


```{r}
ggsave("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210616_gprofiler_mouse_patterns3thru6_FEA_sources_alluvial.pdf", ggalluvial)

```

Alluvial Plot - Mouse  
Looking just at gost profiler GO results
```{r}
#combining gost results for patterns 3:6 with just GO sources
mouse_pattern3_GO <- cbind(mouse_pattern3_GO, pattern = c(rep("pattern_3")))
mouse_pattern4_GO <- cbind(mouse_pattern4_GO, pattern = c(rep("pattern_4")))
mouse_pattern5_GO <- cbind(mouse_pattern5_GO, pattern = c(rep("pattern_5")))
mouse_pattern6_GO <- cbind(mouse_pattern6_GO, pattern = c(rep("pattern_6")))
mouse_GO_3thru6 <- rbind(mouse_pattern3_GO, mouse_pattern4_GO, mouse_pattern5_GO, mouse_pattern6_GO)

ggalluvial_GO <- ggplot(mouse_GO_3thru6,
       aes(axis1 = pattern, axis2 = source, y = term_size)) +
  geom_alluvium(aes(fill = source), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("Pattern", "Pathway"), expand = c(.05, .05)) +
  scale_fill_brewer(type = "qual", palette = "Set1") +
  ggtitle("Mouse Patterns to Pathways")
ggalluvial_GO

```


```{r}
ggsave("/Users/eramsey/Desktop/R21_210302/PreliminaryR21/210616_gprofiler_mouse_patterns3thru6_FEA_GOsources_alluvial.pdf", ggalluvial_GO)

```
